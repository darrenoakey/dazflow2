<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dazflow2</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body, #root {
            width: 100%;
            height: 100%;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
        }
        .editor {
            display: flex;
            width: 100%;
            height: 100%;
        }
        .sidebar {
            width: 200px;
            background: #1a1a2e;
            border-right: 1px solid #3a3a5e;
            padding: 16px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        .sidebar-title {
            font-size: 14px;
            font-weight: bold;
            color: #667eea;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .category-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 8px;
            letter-spacing: 0.5px;
        }
        .category-items {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .node-type-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #2a2a4e;
            border-radius: 8px;
            cursor: grab;
            transition: background 0.15s;
        }
        .node-type-item:hover {
            background: #3a3a5e;
        }
        .node-type-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .node-type-item.disabled:hover {
            background: #2a2a4e;
        }
        .node-type-item svg {
            width: 24px;
            height: 24px;
            color: #667eea;
        }
        .node-type-item span {
            font-size: 13px;
            color: #ccc;
        }
        .canvas-container {
            flex: 1;
            height: 100%;
        }
        .custom-node {
            background: #2a2a4e;
            border: 2px solid #4a4a6e;
            border-radius: 12px;
            padding: 12px;
            min-width: 80px;
            min-height: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .custom-node.selected {
            background: #3a3a5e;
            border-color: #667eea;
        }
        .custom-node.no-inputs {
            border-radius: 30px 12px 12px 30px;
            padding-left: 16px;
        }
        .custom-node.no-outputs {
            border-radius: 12px 30px 30px 12px;
            padding-right: 16px;
        }
        .custom-node.no-inputs.no-outputs {
            border-radius: 30px;
            padding-left: 16px;
            padding-right: 16px;
        }
        .custom-node .node-icon {
            width: 32px;
            height: 32px;
            color: #667eea;
        }
        .custom-node .node-pin-indicator {
            position: absolute;
            top: -6px;
            right: -6px;
            font-size: 12px;
            background: #2a2a4e;
            border-radius: 50%;
            padding: 2px;
            line-height: 1;
        }
        .node-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        .node-wrapper .node-name {
            margin-top: 6px;
            font-size: 10px;
            color: #aaa;
            max-width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            text-align: center;
        }
        .node-wrapper .node-name-input {
            margin-top: 6px;
            font-size: 10px;
            color: #fff;
            background: #2a2a4e;
            border: 1px solid #667eea;
            border-radius: 4px;
            padding: 2px 6px;
            width: 80px;
            text-align: center;
            outline: none;
        }
        .node-wrapper .node-name-input.error {
            border-color: #e74c3c;
            animation: shake 0.3s ease-in-out;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-4px); }
            75% { transform: translateX(4px); }
        }
        .node-wrapper .connector-labels {
            position: absolute;
            top: 0;
            height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            font-size: 8px;
            color: #777;
            pointer-events: none;
        }
        .node-wrapper .connector-labels.left {
            right: 100%;
            margin-right: 8px;
            text-align: right;
        }
        .node-wrapper .connector-labels.right {
            left: 100%;
            margin-left: 8px;
            text-align: left;
        }
        .react-flow__handle {
            width: 10px;
            height: 10px;
            border: 2px solid #4a4a6e;
        }
        .react-flow__handle-left {
            background: #667eea;
        }
        .react-flow__handle-right {
            background: #764ba2;
        }
        .react-flow__edge-path {
            stroke: #5a5a7a;
            stroke-width: 2;
        }
        .react-flow__edge.selected .react-flow__edge-path {
            stroke: #667eea;
            stroke-width: 3;
        }
        .react-flow__background {
            background: #1a1a2e;
        }
        .react-flow__controls button {
            background: #2a2a4e;
            color: #ccc;
            border: 1px solid #4a4a6e;
            border-bottom: none;
        }
        .react-flow__controls button:last-child {
            border-bottom: 1px solid #4a4a6e;
        }
        .react-flow__controls button:hover {
            background: #3a3a5e;
        }
        .edge-button-container {
            position: absolute;
            pointer-events: all;
            display: flex;
            gap: 4px;
        }
        .edge-button {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: none;
            background: #f87171;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }
        .sidebar-hint {
            font-size: 10px;
            color: #555;
            text-align: center;
        }
        .sidebar-footer {
            margin-top: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .view-json-btn {
            padding: 8px 12px;
            background: #3a3a5e;
            border: 1px solid #667eea;
            border-radius: 6px;
            color: #eee;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .view-json-btn:hover {
            background: #4a4a6e;
        }
        .json-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .json-modal {
            background: #1a1a2e;
            border: 1px solid #3a3a5e;
            border-radius: 8px;
            width: 80%;
            max-width: 800px;
            max-height: 80%;
            display: flex;
            flex-direction: column;
        }
        .json-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid #3a3a5e;
        }
        .json-modal-header h3 {
            margin: 0;
            font-size: 14px;
            color: #eee;
        }
        .json-modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        .json-modal-close:hover {
            color: #eee;
        }
        .json-modal-body {
            flex: 1;
            overflow: auto;
            padding: 16px;
        }
        .json-modal-body pre {
            margin: 0;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            color: #9cdcfe;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .json-modal-footer {
            padding: 12px 16px;
            border-top: 1px solid #3a3a5e;
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }
        .json-modal-btn {
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            border: none;
        }
        .json-modal-btn-primary {
            background: #667eea;
            color: #fff;
        }
        .json-modal-btn-primary:hover {
            background: #5a6fd6;
        }

        /* Node Editor Dialog */
        .node-editor-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .node-editor-dialog {
            background: #1a1a2e;
            border: 1px solid #3a3a5e;
            border-radius: 12px;
            width: 95%;
            height: 90%;
            max-width: 1400px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .node-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid #3a3a5e;
            background: #252542;
        }
        .node-editor-header h2 {
            margin: 0;
            font-size: 16px;
            color: #eee;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .node-editor-header .node-icon {
            width: 24px;
            height: 24px;
        }
        .node-editor-close {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        .node-editor-close:hover {
            color: #eee;
        }
        .node-editor-body {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        .node-editor-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .node-editor-pane.input-pane,
        .node-editor-pane.output-pane {
            background: #12121f;
        }
        .node-editor-pane.editor-pane {
            border-left: 1px solid #3a3a5e;
            border-right: 1px solid #3a3a5e;
        }
        .pane-header {
            padding: 12px 16px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #888;
            border-bottom: 1px solid #3a3a5e;
        }
        .pane-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }
        .input-pane .pane-content,
        .output-pane .pane-content {
            color: #666;
            font-size: 12px;
        }
        .no-data-message {
            color: #555;
            font-style: italic;
            font-size: 12px;
        }

        /* Property Editors */
        .property-group {
            margin-bottom: 16px;
        }
        .property-label {
            display: block;
            font-size: 11px;
            font-weight: 600;
            color: #999;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        .property-instructions {
            font-size: 11px;
            color: #7a7a9a;
            margin-bottom: 8px;
            padding: 6px 10px;
            background: #1a1a2e;
            border-radius: 4px;
            border-left: 2px solid #4a4a7a;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
        }
        .property-input {
            width: 100%;
            padding: 10px 12px;
            background: #2a2a4e;
            border: 1px solid #3a3a5e;
            border-radius: 6px;
            color: #eee;
            font-size: 13px;
            outline: none;
            transition: border-color 0.2s;
        }
        .property-input:focus {
            border-color: #667eea;
        }
        .property-input::placeholder {
            color: #555;
        }
        .property-textarea {
            width: 100%;
            padding: 10px 12px;
            background: #2a2a4e;
            border: 1px solid #3a3a5e;
            border-radius: 6px;
            color: #eee;
            font-size: 12px;
            font-family: 'Monaco', 'Menlo', monospace;
            outline: none;
            transition: border-color 0.2s;
            resize: vertical;
            min-height: 120px;
        }
        .property-textarea:focus {
            border-color: #667eea;
        }
        .property-textarea::placeholder {
            color: #555;
        }
        .property-select {
            width: 100%;
            padding: 10px 12px;
            background: #2a2a4e;
            border: 1px solid #3a3a5e;
            border-radius: 6px;
            color: #eee;
            font-size: 13px;
            outline: none;
            cursor: pointer;
        }
        .property-select:focus {
            border-color: #667eea;
        }
        .property-row {
            display: flex;
            gap: 12px;
            align-items: flex-end;
        }
        .property-row .property-group {
            flex: 1;
            margin-bottom: 0;
        }
        .property-description {
            font-size: 11px;
            color: #666;
            margin-top: 4px;
        }

        /* Execute button */
        .execute-btn {
            padding: 8px 16px;
            background: #28a745;
            border: none;
            border-radius: 6px;
            color: #fff;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: background 0.2s;
        }
        .execute-btn:hover {
            background: #218838;
        }
        .execute-btn:disabled {
            background: #555;
            cursor: not-allowed;
        }
        .execute-btn svg {
            width: 14px;
            height: 14px;
        }

        /* JSON output display */
        .json-output {
            background: #1a1a2e;
            border: 1px solid #3a3a5e;
            border-radius: 6px;
            padding: 12px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            color: #9cdcfe;
            white-space: pre-wrap;
            word-break: break-all;
            overflow-y: auto;
            max-height: 100%;
        }
        .json-output .json-key {
            color: #9cdcfe;
        }
        .json-output .json-string {
            color: #ce9178;
        }
        .json-output .json-number {
            color: #b5cea8;
        }
        .execution-time {
            font-size: 10px;
            color: #666;
            margin-bottom: 8px;
        }

        /* Field list property editor */
        .field-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .field-item {
            display: flex;
            gap: 8px;
            align-items: flex-start;
            background: #252542;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #3a3a5e;
        }
        .field-item-inputs {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .field-item-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .field-item-row label {
            font-size: 10px;
            color: #777;
            min-width: 40px;
        }
        .field-item-row input {
            flex: 1;
            padding: 6px 8px;
            background: #1a1a2e;
            border: 1px solid #3a3a5e;
            border-radius: 4px;
            color: #eee;
            font-size: 12px;
        }
        .field-item-row input:focus {
            outline: none;
            border-color: #667eea;
        }
        .field-delete-btn {
            background: none;
            border: none;
            color: #888;
            font-size: 18px;
            cursor: pointer;
            padding: 4px;
            line-height: 1;
        }
        .field-delete-btn:hover {
            color: #e74c3c;
        }
        .add-field-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 8px 12px;
            background: #2a2a4e;
            border: 1px dashed #4a4a6e;
            border-radius: 6px;
            color: #888;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .add-field-btn:hover {
            background: #3a3a5e;
            border-color: #667eea;
            color: #eee;
        }
        .add-field-btn svg {
            width: 14px;
            height: 14px;
        }

        /* Expression indicator */
        .expr-input-wrapper {
            position: relative;
        }
        .expr-indicator {
            position: absolute;
            right: 4px;
            bottom: 4px;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-bottom: 10px solid #28a745;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
            z-index: 10;
        }
        .expr-indicator:hover {
            opacity: 1;
        }
        .expr-indicator.has-error {
            border-bottom-color: #e74c3c;
        }
        /* Contenteditable styling */
        .expr-input-wrapper [contenteditable] {
            outline: none;
        }
        .expr-input-wrapper [contenteditable]:empty:before {
            content: attr(data-placeholder);
            color: #555;
        }

        /* Expression Editor Modal */
        .expr-editor-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1100;
        }
        .expr-editor-dialog {
            background: #1a1a2e;
            border: 1px solid #3a3a5e;
            border-radius: 12px;
            width: 90%;
            max-width: 1200px;
            height: 80%;
            max-height: 700px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .expr-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid #3a3a5e;
            background: #252542;
        }
        .expr-editor-header h3 {
            margin: 0;
            font-size: 14px;
            color: #eee;
        }
        .expr-editor-close {
            background: none;
            border: none;
            color: #888;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        .expr-editor-close:hover {
            color: #eee;
        }
        .expr-editor-body {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        .expr-editor-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 0;
        }
        .expr-editor-pane.input-pane {
            background: #12121f;
        }
        .expr-editor-pane.expr-pane {
            border-left: 1px solid #3a3a5e;
            border-right: 1px solid #3a3a5e;
        }
        .expr-editor-pane.result-pane {
            background: #12121f;
        }
        .expr-pane-header {
            padding: 10px 14px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #888;
            border-bottom: 1px solid #3a3a5e;
        }
        .expr-pane-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }
        .expr-input-textarea {
            width: 100%;
            height: 100%;
            min-height: 200px;
            background: #1a1a2e;
            border: 1px solid #3a3a5e;
            border-radius: 6px;
            color: #eee;
            font-size: 13px;
            font-family: 'Monaco', 'Menlo', monospace;
            padding: 12px;
            resize: none;
            outline: none;
        }
        .expr-input-textarea:focus {
            border-color: #667eea;
        }
        .expr-result-display {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
        }
        .expr-result-error {
            color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
            padding: 8px 12px;
            border-radius: 4px;
            margin-bottom: 8px;
        }
        .expr-result-value {
            color: #9cdcfe;
        }
        .expr-editor-footer {
            padding: 12px 16px;
            border-top: 1px solid #3a3a5e;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }
        .expr-editor-btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            border: none;
        }
        .expr-editor-btn-primary {
            background: #667eea;
            color: #fff;
        }
        .expr-editor-btn-primary:hover {
            background: #5a6fd6;
        }
        .expr-editor-btn-cancel {
            background: #3a3a5e;
            color: #ccc;
        }
        .expr-editor-btn-cancel:hover {
            background: #4a4a6e;
        }
        /* Draggable JSON paths */
        .json-draggable {
            cursor: grab;
        }
        .json-draggable:hover {
            background: rgba(102, 126, 234, 0.2);
            border-radius: 2px;
        }
        .json-draggable:active {
            cursor: grabbing;
        }

        /* JSON Viewer styles */
        .json-viewer {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            line-height: 1.5;
        }
        .json-indent {
            margin-left: 16px;
        }
        .json-bracket {
            color: #888;
        }
        .json-toggle {
            cursor: pointer;
            user-select: none;
        }
        .json-toggle:hover {
            color: #667eea;
        }
        .json-key {
            color: #9cdcfe;
        }
        .json-colon {
            color: #888;
        }
        .json-comma {
            color: #888;
        }
        .json-string {
            color: #ce9178;
        }
        .json-number {
            color: #b5cea8;
        }
        .json-boolean {
            color: #569cd6;
        }
        .json-null {
            color: #569cd6;
        }
        .json-undefined {
            color: #888;
            font-style: italic;
        }
        .json-property {
            display: block;
        }
        .json-array-item {
            display: block;
        }

        /* Dashboard Styles */
        .dashboard {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background: #1a1a2e;
        }
        .dashboard-header {
            padding: 24px 32px;
            border-bottom: 1px solid #3a3a5e;
        }
        .dashboard-title {
            font-size: 28px;
            font-weight: bold;
            color: #667eea;
            margin: 0 0 16px 0;
        }
        .dashboard-tabs {
            display: flex;
            gap: 0;
        }
        .dashboard-tab {
            padding: 10px 24px;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: #888;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .dashboard-tab:hover {
            color: #ccc;
        }
        .dashboard-tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }
        .dashboard-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px 32px;
        }
        /* Credentials Tab Styles */
        .credentials-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .credential-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: #2a2a4e;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .credential-item:hover {
            background: #3a3a5e;
        }
        .credential-icon {
            width: 20px;
            height: 20px;
            color: #667eea;
        }
        .credential-info {
            flex: 1;
        }
        .credential-name {
            font-size: 14px;
            color: #eee;
        }
        .credential-type {
            font-size: 12px;
            color: #888;
        }
        .credential-actions {
            display: flex;
            gap: 8px;
        }
        .credential-action-btn {
            padding: 4px 8px;
            background: transparent;
            border: 1px solid #4a4a6e;
            border-radius: 4px;
            color: #888;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .credential-action-btn:hover {
            background: #3a3a5e;
            color: #eee;
        }
        .credential-action-btn.delete:hover {
            background: #8b2942;
            border-color: #8b2942;
        }
        .credential-action-btn.test:hover {
            background: #2a5e4e;
            border-color: #2a5e4e;
        }
        .credential-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .credential-modal-content {
            background: #1a1a2e;
            border: 1px solid #3a3a5e;
            border-radius: 12px;
            padding: 24px;
            width: 450px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .credential-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .credential-modal-title {
            font-size: 18px;
            font-weight: 600;
            color: #eee;
        }
        .credential-modal-close {
            background: transparent;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        .credential-modal-close:hover {
            color: #eee;
        }
        .credential-form-group {
            margin-bottom: 16px;
        }
        .credential-form-label {
            display: block;
            font-size: 13px;
            color: #888;
            margin-bottom: 6px;
        }
        .credential-form-input {
            width: 100%;
            padding: 10px 12px;
            background: #2a2a4e;
            border: 1px solid #4a4a6e;
            border-radius: 6px;
            color: #eee;
            font-size: 14px;
        }
        .credential-form-input:focus {
            outline: none;
            border-color: #667eea;
        }
        .credential-form-input.hidden-value {
            color: #888;
            font-style: italic;
        }
        .credential-modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 24px;
        }
        .credential-modal-btn {
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            border: none;
        }
        .credential-modal-btn.cancel {
            background: #3a3a5e;
            color: #eee;
        }
        .credential-modal-btn.cancel:hover {
            background: #4a4a6e;
        }
        .credential-modal-btn.save {
            background: #667eea;
            color: #fff;
        }
        .credential-modal-btn.save:hover {
            background: #5a6fd6;
        }
        .credential-modal-btn.save:disabled {
            background: #4a4a6e;
            color: #888;
            cursor: not-allowed;
        }
        .credential-modal-btn.test-passed {
            background: #2a4e2a;
            color: #8c8;
        }
        .credential-modal-btn.test-passed:hover {
            background: #3a5e3a;
        }
        .credential-test-result {
            margin-top: 16px;
            padding: 12px;
            border-radius: 6px;
            font-size: 13px;
        }
        .credential-test-result.success {
            background: #1a4a3e;
            color: #4ade80;
        }
        .credential-test-result.failure {
            background: #4a1a2e;
            color: #f87171;
        }
        .workflows-toolbar {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
        }
        .toolbar-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            background: #3a3a5e;
            border: none;
            border-radius: 6px;
            color: #eee;
            font-size: 13px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .toolbar-btn:hover {
            background: #4a4a6e;
        }
        .toolbar-btn-icon {
            width: 14px;
            height: 14px;
        }
        .toolbar-btn-icon svg {
            width: 100%;
            height: 100%;
        }
        .file-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .file-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: #2a2a4e;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .file-item:hover {
            background: #3a3a5e;
        }
        .file-item.drag-over {
            background: #4a4a6e;
            outline: 2px dashed #667eea;
            outline-offset: -2px;
        }
        .file-item.folder {
            border-left: 3px solid #667eea;
        }
        .file-item.workflow {
            border-left: 3px solid #764ba2;
        }
        .file-item-icon {
            width: 20px;
            height: 20px;
            color: #888;
        }
        .file-item-name {
            flex: 1;
            color: #eee;
            font-size: 14px;
        }
        .file-item-stats {
            display: flex;
            gap: 16px;
            font-size: 12px;
            color: #666;
        }
        .file-item-stat {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .toggle-btn {
            padding: 4px 12px;
            border-radius: 12px;
            border: 1px solid #3a3a5e;
            background: #2a2a4e;
            color: #888;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        .toggle-btn:hover {
            border-color: #667eea;
        }
        .toggle-btn.enabled {
            background: #667eea;
            border-color: #667eea;
            color: #fff;
        }
        .file-item-menu {
            position: relative;
        }
        .file-item-menu-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            background: transparent;
            border: none;
            border-radius: 4px;
            color: #666;
            cursor: pointer;
            transition: all 0.15s;
        }
        .file-item-menu-btn:hover {
            background: #3a3a5e;
            color: #fff;
        }
        .file-item-menu-btn svg {
            width: 16px;
            height: 16px;
        }
        .file-item-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            min-width: 120px;
            background: #2a2a4e;
            border: 1px solid #3a3a5e;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 100;
            overflow: hidden;
        }
        .file-item-dropdown-item {
            display: block;
            width: 100%;
            padding: 10px 14px;
            background: transparent;
            border: none;
            color: #eee;
            font-size: 13px;
            text-align: left;
            cursor: pointer;
            transition: background 0.15s;
        }
        .file-item-dropdown-item:hover {
            background: #3a3a5e;
        }
        .executions-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }
        .execution-item {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 12px 16px;
            background: #2a2a4e;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .execution-item:hover {
            background: #3a3a5e;
        }
        .execution-item.completed {
            border-left: 3px solid #4caf50;
        }
        .execution-item.error {
            border-left: 3px solid #f44336;
        }
        .exec-time {
            color: #888;
            font-size: 13px;
            min-width: 160px;
        }
        .exec-workflow {
            flex: 1;
            color: #eee;
            font-size: 14px;
        }
        .exec-status {
            font-size: 16px;
        }
        .exec-status.completed {
            color: #4caf50;
        }
        .exec-status.error {
            color: #f44336;
        }
        .exec-duration {
            color: #888;
            font-size: 13px;
            min-width: 60px;
            text-align: right;
        }
        .executions-loading {
            text-align: center;
            padding: 20px;
            color: #888;
        }
        .readonly-banner {
            background: linear-gradient(135deg, #5a4a2e 0%, #4a3a1e 100%);
            color: #ffd54f;
            padding: 10px 16px;
            font-size: 13px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #6a5a3e;
        }
        .readonly-banner-text {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .readonly-banner-close {
            background: transparent;
            border: 1px solid #8a7a4e;
            border-radius: 4px;
            color: #ffd54f;
            padding: 4px 12px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.15s;
        }
        .readonly-banner-close:hover {
            background: #6a5a3e;
        }
        .sidebar-actions {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        .back-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            background: #2a2a4e;
            border: 1px solid #3a3a5e;
            border-radius: 6px;
            color: #888;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .back-btn:hover {
            background: #3a3a5e;
            color: #eee;
        }
        .save-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            background: #2a4e2a;
            border: 1px solid #3a5e3a;
            border-radius: 6px;
            color: #8c8;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .save-btn:hover {
            background: #3a5e3a;
            color: #afa;
        }
        .save-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .save-btn.saved {
            background: #1a4a1a;
            color: #6c6;
        }
        .save-btn.error {
            background: #4a1a1a;
            border-color: #5a2a2a;
            color: #c66;
        }
        .empty-state {
            text-align: center;
            padding: 48px;
            color: #666;
            font-size: 14px;
        }
    </style>
    <link href="https://esm.sh/@xyflow/react@12/dist/style.css" rel="stylesheet">
</head>
<body>
    <div id="root"></div>

    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18",
            "react-dom": "https://esm.sh/react-dom@18",
            "react-dom/client": "https://esm.sh/react-dom@18/client",
            "react/jsx-runtime": "https://esm.sh/react@18/jsx-runtime",
            "@xyflow/react": "https://esm.sh/@xyflow/react@12?external=react,react-dom",
            "zustand": "https://esm.sh/zustand@4?external=react",
            "uuid": "https://esm.sh/uuid@9",
            "nodes": "/nodes/index.js"
        }
    }
    </script>

    <script type="module">
        import React, { useState, useCallback, useMemo, useRef, useEffect, memo } from 'react';
        import { createRoot } from 'react-dom/client';
        import {
            ReactFlow,
            Background,
            Controls,
            Handle,
            Position,
            ReactFlowProvider,
            useReactFlow,
            applyNodeChanges,
            applyEdgeChanges,
            getBezierPath,
            EdgeLabelRenderer,
            BaseEdge,
        } from '@xyflow/react';
        import { create } from 'zustand';
        import { v4 as uuid } from 'uuid';
        import { nodeTypeDefinitions, getNodeTypesByCategory, loadModules } from 'nodes';

        // LocalStorage key for persistence
        const STORAGE_KEY = 'dazflow2-workflow';

        // Load state from localStorage
        function loadFromStorage() {
            try {
                const stored = localStorage.getItem(STORAGE_KEY);
                if (stored) {
                    const parsed = JSON.parse(stored);
                    return {
                        nodes: parsed.nodes || [],
                        connections: parsed.connections || [],
                        nameCounts: parsed.nameCounts || {},
                        viewport: parsed.viewport || { x: 0, y: 0, zoom: 1 },
                    };
                }
            } catch (e) {
                console.warn('Failed to load from localStorage:', e);
            }
            return null;
        }

        // Expression evaluation utilities
        // Evaluates a single JavaScript expression with $ as the input data
        function evaluateExpression(expr, $) {
            try {
                // Create a function that has $ in scope and evaluates the expression
                const fn = new Function('$', `return (${expr})`);
                return { value: fn($), error: null };
            } catch (e) {
                return { value: null, error: e.message };
            }
        }

        // Parse a template string and find all {{...}} expression blocks
        function parseTemplate(template) {
            const parts = [];
            const regex = /\{\{([\s\S]*?)\}\}/g;
            let lastIndex = 0;
            let match;

            while ((match = regex.exec(template)) !== null) {
                // Add text before this expression
                if (match.index > lastIndex) {
                    parts.push({ type: 'text', value: template.slice(lastIndex, match.index) });
                }
                // Add the expression
                parts.push({ type: 'expr', value: match[1], raw: match[0] });
                lastIndex = regex.lastIndex;
            }

            // Add remaining text
            if (lastIndex < template.length) {
                parts.push({ type: 'text', value: template.slice(lastIndex) });
            }

            return parts;
        }

        // Evaluate a template string, returning both the result and details for UI
        // Returns: { result: string, parts: [{ type, value, evaluated, error }] }
        function evaluateTemplate(template, $) {
            if (!template || typeof template !== 'string') {
                return { result: template, parts: [], hasExpressions: false };
            }

            const parts = parseTemplate(template);
            if (parts.length === 0) {
                return { result: '', parts: [], hasExpressions: false };
            }

            const hasExpressions = parts.some(p => p.type === 'expr');
            const evaluatedParts = parts.map(part => {
                if (part.type === 'text') {
                    return { ...part, evaluated: part.value, error: null };
                } else {
                    const { value, error } = evaluateExpression(part.value, $);
                    const evaluated = error ? '' : (typeof value === 'object' ? JSON.stringify(value) : String(value));
                    return { ...part, evaluated, error };
                }
            });

            const hasErrors = evaluatedParts.some(p => p.error);
            const result = hasErrors ? null : evaluatedParts.map(p => p.evaluated).join('');

            return { result, parts: evaluatedParts, hasExpressions, hasErrors };
        }

        // Get the JSON path for a value in an object (for drag-and-drop)
        function getJsonPath(obj, targetPath = []) {
            return '$' + targetPath.map(key => {
                // Use bracket notation for keys with special characters or numbers
                if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key)) {
                    return '.' + key;
                } else {
                    return `[${JSON.stringify(key)}]`;
                }
            }).join('');
        }

        // Recursively evaluate all expressions in a data structure
        // This is used at execution time to resolve {{...}} in node data
        function evaluateDataExpressions(data, $) {
            if (data === null || data === undefined) {
                return data;
            }
            if (typeof data === 'string') {
                const result = evaluateTemplate(data, $);
                // If template has expressions and evaluates successfully, return result
                // If it's pure expression returning non-string, try to preserve type
                if (result.hasExpressions && !result.hasErrors) {
                    // If entire template is one expression, return the actual value (preserve type)
                    if (result.parts.length === 1 && result.parts[0].type === 'expr') {
                        const { value } = evaluateExpression(result.parts[0].value, $);
                        return value;
                    }
                    return result.result;
                }
                return data; // Return original if no expressions or has errors
            }
            if (Array.isArray(data)) {
                return data.map(item => evaluateDataExpressions(item, $));
            }
            if (typeof data === 'object') {
                const result = {};
                for (const [key, value] of Object.entries(data)) {
                    // Evaluate both keys and values
                    const evaluatedKey = evaluateDataExpressions(key, $);
                    result[evaluatedKey] = evaluateDataExpressions(value, $);
                }
                return result;
            }
            return data;
        }

        // Expose for use by node modules
        window.evaluateDataExpressions = evaluateDataExpressions;

        // Save state to localStorage
        function saveToStorage(state) {
            try {
                const toSave = {
                    nodes: state.nodes,
                    connections: state.connections,
                    nameCounts: state.nameCounts,
                    viewport: state.viewport,
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(toSave));
            } catch (e) {
                console.warn('Failed to save to localStorage:', e);
            }
        }

        // Load initial state from localStorage
        const initialState = loadFromStorage();

        // Zustand store for workflow state
        const useWorkflowStore = create((set, get) => ({
            nodes: initialState?.nodes || [],
            connections: initialState?.connections || [],
            selectedNodeIds: [],
            selectedEdgeIds: [],
            nameCounts: initialState?.nameCounts || {},
            viewport: initialState?.viewport || { x: 0, y: 0, zoom: 1 },
            editingNodeId: null,
            openEditorNodeId: null,

            // Dashboard state
            currentView: 'dashboard', // 'dashboard' | 'editor'
            currentWorkflowPath: null,
            dashboardPath: '',
            dashboardTab: (() => {
                // Initialize from URL pathname
                const path = window.location.pathname;
                if (path === '/executions') return 'executions';
                if (path === '/credentials') return 'credentials';
                return 'workflows';
            })(),
            dashboardItems: [],
            dashboardLoading: false,

            // Ambient execution - stores the most recent execution results for each node
            // Format: { [nodeId]: { input, nodeOutput, output (combined), executedAt } }
            ambientExecution: {},

            // Dashboard actions
            setCurrentView: (view) => set({ currentView: view }),
            setDashboardPath: (path) => set({ dashboardPath: path }),
            setDashboardTab: (tab) => {
                const url = tab === 'workflows' ? '/' : `/${tab}`;
                history.pushState(null, '', url);
                set({ dashboardTab: tab });
            },
            setDashboardItems: (items) => set({ dashboardItems: items }),

            // Load workflows from server
            loadDashboardItems: async (path = '') => {
                set({ dashboardLoading: true });
                try {
                    const response = await fetch(`/api/workflows?path=${encodeURIComponent(path)}`);
                    if (response.ok) {
                        const data = await response.json();
                        set({ dashboardItems: data.items, dashboardPath: path });
                    }
                } catch (e) {
                    console.error('Failed to load workflows:', e);
                } finally {
                    set({ dashboardLoading: false });
                }
            },

            // Load a workflow and switch to editor
            loadWorkflow: async (path) => {
                try {
                    const response = await fetch(`/api/workflow/${encodeURIComponent(path)}`);
                    if (response.ok) {
                        const workflow = await response.json();
                        // Strip .json from URL for cleaner paths
                        const urlPath = path.replace(/\.json$/, '');
                        history.pushState(null, '', `/editor/${urlPath}`);
                        set({
                            nodes: workflow.nodes || [],
                            connections: workflow.connections || [],
                            nameCounts: {},
                            viewport: { x: 0, y: 0, zoom: 1 },
                            ambientExecution: {},
                            currentWorkflowPath: path,
                            currentView: 'editor',
                        });
                    }
                } catch (e) {
                    console.error('Failed to load workflow:', e);
                }
            },

            // Save current workflow
            saveWorkflow: async (path) => {
                const state = get();
                const workflow = { nodes: state.nodes, connections: state.connections };
                try {
                    const response = await fetch(`/api/workflow/${encodeURIComponent(path)}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ workflow }),
                    });
                    return response.ok;
                } catch (e) {
                    console.error('Failed to save workflow:', e);
                    return false;
                }
            },

            // Go back to dashboard
            goToDashboard: () => {
                history.pushState(null, '', '/');
                set({ currentView: 'dashboard', currentWorkflowPath: null, isReadOnly: false, executionViewerId: null });
                get().loadDashboardItems(get().dashboardPath);
            },

            // Read-only mode for viewing historical executions
            isReadOnly: false,
            executionViewerId: null,
            executionViewerData: null,

            // Executions list state
            executionsList: [],
            executionsLoading: false,
            executionsHasMore: true,
            executionsBeforeCursor: null,

            // Load paginated executions list
            loadExecutionsList: async (reset = false) => {
                const state = get();
                if (state.executionsLoading) return;

                set({ executionsLoading: true });
                try {
                    const before = reset ? null : state.executionsBeforeCursor;
                    const url = before
                        ? `/api/executions?limit=50&before=${before}`
                        : '/api/executions?limit=50';
                    const response = await fetch(url);
                    if (response.ok) {
                        const data = await response.json();
                        const newItems = reset ? data.items : [...state.executionsList, ...data.items];
                        const lastItem = data.items[data.items.length - 1];
                        set({
                            executionsList: newItems,
                            executionsHasMore: data.has_more,
                            executionsBeforeCursor: lastItem?.completed_at || null,
                        });
                    }
                } catch (e) {
                    console.error('Failed to load executions:', e);
                } finally {
                    set({ executionsLoading: false });
                }
            },

            // Load a historical execution and open in read-only editor
            loadExecution: async (id) => {
                try {
                    const response = await fetch(`/api/execution/${encodeURIComponent(id)}`);
                    if (response.ok) {
                        const data = await response.json();
                        history.pushState(null, '', `/execution/${id}`);
                        set({
                            currentView: 'editor',
                            nodes: data.workflow.nodes || [],
                            connections: data.workflow.connections || [],
                            nameCounts: {},
                            viewport: { x: 0, y: 0, zoom: 1 },
                            ambientExecution: data.execution || {},
                            executionViewerId: id,
                            executionViewerData: data,
                            isReadOnly: true,
                            currentWorkflowPath: data.workflow_path,
                        });
                    }
                } catch (e) {
                    console.error('Failed to load execution:', e);
                }
            },

            // Close execution viewer and return to executions tab
            closeExecutionViewer: () => {
                history.pushState(null, '', '/executions');
                set({
                    currentView: 'dashboard',
                    dashboardTab: 'executions',
                    isReadOnly: false,
                    executionViewerId: null,
                    executionViewerData: null,
                });
            },

            setViewport: (viewport) => set({ viewport }),
            setEditingNodeId: (nodeId) => set({ editingNodeId: nodeId }),
            setOpenEditorNodeId: (nodeId) => set({ openEditorNodeId: nodeId }),

            // Store execution result for a node in the ambient execution
            // input: data received from upstream
            // nodeOutput: what this specific node produced
            // output: combined result (input merged with nodeOutput)
            setNodeExecution: (nodeId, input, nodeOutput, output) => {
                set((state) => ({
                    ambientExecution: {
                        ...state.ambientExecution,
                        [nodeId]: {
                            input,
                            nodeOutput,
                            output: output || nodeOutput, // If no combined provided, use nodeOutput
                            executedAt: new Date().toISOString(),
                        },
                    },
                }));
            },

            // Get execution result for a node
            getNodeExecution: (nodeId) => {
                return get().ambientExecution[nodeId] || null;
            },

            updateNodeData: (nodeId, dataUpdates) => {
                set((state) => ({
                    nodes: state.nodes.map((n) =>
                        n.id === nodeId ? { ...n, data: { ...n.data, ...dataUpdates } } : n
                    ),
                }));
            },

            isNameUnique: (name, excludeNodeId) => {
                const state = get();
                return !state.nodes.some((n) => n.id !== excludeNodeId && n.name === name);
            },

            updateNodeName: (nodeId, name) => {
                set((state) => ({
                    nodes: state.nodes.map((n) => (n.id === nodeId ? { ...n, name } : n)),
                    editingNodeId: null,
                }));
            },

            addNode: (typeId, position, credentialName = null) => {
                const nodeType = nodeTypeDefinitions[typeId];
                if (!nodeType) return '';

                const id = uuid();
                const state = get();
                const count = (state.nameCounts[typeId] || 0) + 1;
                const name = `${typeId}${count}`;

                // Build node data, including credentialName if provided
                const nodeData = { ...nodeType.defaultData };
                if (credentialName) {
                    nodeData.credentialName = credentialName;
                }

                const newNode = {
                    id,
                    typeId,
                    name,
                    position,
                    data: nodeData,
                };

                set({
                    nodes: [...state.nodes, newNode],
                    nameCounts: { ...state.nameCounts, [typeId]: count },
                });

                return id;
            },

            removeNode: (nodeId) => {
                const state = get();
                const newConnections = state.connections.filter(
                    (c) => c.sourceNodeId !== nodeId && c.targetNodeId !== nodeId
                );
                set({
                    nodes: state.nodes.filter((n) => n.id !== nodeId),
                    connections: newConnections,
                    selectedNodeIds: state.selectedNodeIds.filter((id) => id !== nodeId),
                });
            },

            updateNodePosition: (nodeId, position) => {
                set((state) => ({
                    nodes: state.nodes.map((n) => (n.id === nodeId ? { ...n, position } : n)),
                }));
            },

            addConnection: (connection) => {
                const state = get();
                if (connection.sourceNodeId === connection.targetNodeId) return null;

                const isDuplicate = state.connections.some(
                    (c) =>
                        c.sourceNodeId === connection.sourceNodeId &&
                        c.sourceConnectorId === connection.sourceConnectorId &&
                        c.targetNodeId === connection.targetNodeId &&
                        c.targetConnectorId === connection.targetConnectorId
                );
                if (isDuplicate) return null;

                const id = uuid();
                set({
                    connections: [...state.connections, { ...connection, id }],
                });
                return id;
            },

            removeConnection: (connectionId) => {
                set((state) => ({
                    connections: state.connections.filter((c) => c.id !== connectionId),
                    selectedEdgeIds: state.selectedEdgeIds.filter((id) => id !== connectionId),
                }));
            },

            selectNodes: (nodeIds) => set({ selectedNodeIds: nodeIds, selectedEdgeIds: [] }),
            selectEdges: (edgeIds) => set({ selectedEdgeIds: edgeIds, selectedNodeIds: [] }),
            clearSelection: () => set({ selectedNodeIds: [], selectedEdgeIds: [] }),

            deleteSelected: () => {
                const state = get();
                let newConnections = state.connections.filter((c) => !state.selectedEdgeIds.includes(c.id));
                for (const nodeId of state.selectedNodeIds) {
                    newConnections = newConnections.filter(
                        (c) => c.sourceNodeId !== nodeId && c.targetNodeId !== nodeId
                    );
                }
                set({
                    nodes: state.nodes.filter((n) => !state.selectedNodeIds.includes(n.id)),
                    connections: newConnections,
                    selectedNodeIds: [],
                    selectedEdgeIds: [],
                });
            },

            // Credentials state
            credentials: [],
            credentialsLoading: false,
            editingCredential: null, // { name, type, data, isNew }

            // Load credentials from server
            loadCredentials: async () => {
                set({ credentialsLoading: true });
                try {
                    const response = await fetch('/api/credentials');
                    if (response.ok) {
                        const data = await response.json();
                        set({ credentials: data.credentials || [] });
                    }
                } catch (e) {
                    console.error('Failed to load credentials:', e);
                } finally {
                    set({ credentialsLoading: false });
                }
            },

            // Save a credential
            saveCredentialToServer: async (name, type, data) => {
                try {
                    const response = await fetch(`/api/credential/${encodeURIComponent(name)}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ type, data }),
                    });
                    if (response.ok) {
                        await get().loadCredentials();
                        return true;
                    }
                } catch (e) {
                    console.error('Failed to save credential:', e);
                }
                return false;
            },

            // Delete a credential
            deleteCredentialFromServer: async (name) => {
                try {
                    const response = await fetch(`/api/credential/${encodeURIComponent(name)}`, {
                        method: 'DELETE',
                    });
                    if (response.ok) {
                        await get().loadCredentials();
                        return true;
                    }
                } catch (e) {
                    console.error('Failed to delete credential:', e);
                }
                return false;
            },

            // Test a credential by name (for existing credentials)
            testCredentialOnServer: async (name) => {
                try {
                    const response = await fetch(`/api/credential/${encodeURIComponent(name)}/test`, {
                        method: 'POST',
                    });
                    if (response.ok) {
                        return await response.json();
                    }
                } catch (e) {
                    console.error('Failed to test credential:', e);
                }
                return { status: false, message: 'Request failed' };
            },

            // Test credential data directly (for new credentials)
            testCredentialData: async (credType, data) => {
                try {
                    const response = await fetch('/api/credential-test', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ type: credType, data }),
                    });
                    if (response.ok) {
                        return await response.json();
                    }
                } catch (e) {
                    console.error('Failed to test credential data:', e);
                }
                return { status: false, message: 'Request failed' };
            },

            setEditingCredential: (cred) => set({ editingCredential: cred }),
        }));

        // Subscribe to store changes and save to localStorage
        useWorkflowStore.subscribe((state) => {
            saveToStorage(state);
        });

        // Expose store globally for testing
        window.useWorkflowStore = useWorkflowStore;

        // Global double-click detection for nodes using position-based hit testing
        // This works around a React/ReactFlow issue where DOM elements get replaced between clicks
        (function setupGlobalNodeDoubleClick() {
            let lastMouseDown = { time: 0, nodeId: null, x: 0, y: 0 };

            // Find which node (if any) contains the given point
            function findNodeAtPoint(x, y) {
                const nodeWrappers = document.querySelectorAll('[data-node-id]');
                for (const wrapper of nodeWrappers) {
                    const rect = wrapper.getBoundingClientRect();
                    if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                        return wrapper.getAttribute('data-node-id');
                    }
                }
                return null;
            }

            document.addEventListener('mousedown', (e) => {
                const now = Date.now();
                const nodeId = findNodeAtPoint(e.clientX, e.clientY);

                if (!nodeId) {
                    lastMouseDown = { time: 0, nodeId: null, x: 0, y: 0 };
                    return;
                }

                // Check if this is a double-click (same node, within 400ms, position close)
                const isSameNode = lastMouseDown.nodeId === nodeId;
                const isQuickEnough = now - lastMouseDown.time < 400;
                const isCloseEnough = Math.abs(e.clientX - lastMouseDown.x) < 10 && Math.abs(e.clientY - lastMouseDown.y) < 10;

                if (isSameNode && isQuickEnough && isCloseEnough) {
                    // Double-click detected
                    e.stopPropagation();
                    e.preventDefault();
                    useWorkflowStore.getState().setOpenEditorNodeId(nodeId);
                    lastMouseDown = { time: 0, nodeId: null, x: 0, y: 0 };
                } else {
                    lastMouseDown = { time: now, nodeId, x: e.clientX, y: e.clientY };
                }
            }, true); // capture phase
        })();

        // Custom Node Component
        const CustomNode = memo(function CustomNode({ data, selected }) {
            const workflowNode = data.workflowNode;
            const nodeType = nodeTypeDefinitions[workflowNode.typeId];
            const editingNodeId = useWorkflowStore((state) => state.editingNodeId);
            const updateNodeName = useWorkflowStore((state) => state.updateNodeName);
            const setEditingNodeId = useWorkflowStore((state) => state.setEditingNodeId);
            const isNameUnique = useWorkflowStore((state) => state.isNameUnique);
            const isEditing = editingNodeId === workflowNode.id;
            const inputRef = useRef(null);
            const [nameError, setNameError] = useState(false);

            const connectors = useMemo(() => {
                if (!nodeType) return { inputs: [], outputs: [] };
                return nodeType.getConnectors(workflowNode.data);
            }, [nodeType, workflowNode.data]);

            // Focus input when editing starts
            useEffect(() => {
                if (isEditing && inputRef.current) {
                    inputRef.current.focus();
                    inputRef.current.select();
                    setNameError(false);
                }
            }, [isEditing]);

            if (!nodeType) return null;

            // Check if node is pinned
            const isPinned = workflowNode.data?.pinned || false;

            const inputCount = connectors.inputs.length;
            const outputCount = connectors.outputs.length;
            const shapeClasses = [
                inputCount === 0 ? 'no-inputs' : '',
                outputCount === 0 ? 'no-outputs' : '',
            ].filter(Boolean).join(' ');

            const handleNameKeyDown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.target.blur(); // This will trigger onBlur which saves
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    e.target.dataset.cancelled = 'true';
                    setNameError(false);
                    setEditingNodeId(null);
                }
            };

            const handleNameBlur = (e) => {
                if (e.target.dataset.cancelled !== 'true') {
                    const newName = e.target.value.trim() || workflowNode.name;
                    if (newName !== workflowNode.name && !isNameUnique(newName, workflowNode.id)) {
                        // Name is not unique - show error and keep editing
                        setNameError(true);
                        e.target.focus();
                        e.target.select();
                        return;
                    }
                    setNameError(false);
                    updateNodeName(workflowNode.id, newName);
                }
            };

            return React.createElement('div', {
                className: 'node-wrapper',
                'data-testid': `workflow-node-${workflowNode.typeId}`,
                'data-node-id': workflowNode.id,
            }, [
                // Input labels (outside node, to the left)
                inputCount > 0 && React.createElement('div', {
                    key: 'input-labels',
                    className: 'connector-labels left',
                }, connectors.inputs.map((i) => React.createElement('span', { key: i.id }, i.name))),
                // Output labels (outside node, to the right)
                outputCount > 0 && React.createElement('div', {
                    key: 'output-labels',
                    className: 'connector-labels right',
                }, connectors.outputs.map((o) => React.createElement('span', { key: o.id }, o.name))),
                // The actual node box (double-click handled by global position-based detection)
                React.createElement('div', {
                    key: 'node',
                    className: `custom-node ${selected ? 'selected' : ''} ${shapeClasses}`,
                }, [
                    // Input handles
                    ...connectors.inputs.map((input, idx) => {
                        const top = inputCount === 1 ? '50%' : `${((idx + 1) / (inputCount + 1)) * 100}%`;
                        return React.createElement(Handle, {
                            key: input.id,
                            type: 'target',
                            position: Position.Left,
                            id: input.id,
                            style: { top },
                            title: input.name,
                        });
                    }),
                    // Icon
                    React.createElement('div', {
                        key: 'icon',
                        className: 'node-icon',
                        dangerouslySetInnerHTML: { __html: nodeType.icon },
                    }),
                    // Pin indicator
                    isPinned && React.createElement('div', {
                        key: 'pin-indicator',
                        className: 'node-pin-indicator',
                        title: 'Pinned output',
                    }, ''),
                    // Output handles
                    ...connectors.outputs.map((output, idx) => {
                        const top = outputCount === 1 ? '50%' : `${((idx + 1) / (outputCount + 1)) * 100}%`;
                        return React.createElement(Handle, {
                            key: output.id,
                            type: 'source',
                            position: Position.Right,
                            id: output.id,
                            style: { top },
                            title: output.name,
                        });
                    }),
                ]),
                // Node name (below the node) - input if editing, text if not
                isEditing
                    ? React.createElement('input', {
                        key: 'name-input',
                        ref: inputRef,
                        className: `node-name-input nodrag${nameError ? ' error' : ''}`,
                        defaultValue: workflowNode.name,
                        autoFocus: true,
                        onKeyDown: handleNameKeyDown,
                        onBlur: handleNameBlur,
                        'data-testid': 'node-name-input',
                    })
                    : React.createElement('div', {
                        key: 'name',
                        className: 'node-name',
                    }, workflowNode.name),
            ]);
        });

        // Custom Edge Component
        const CustomEdge = memo(function CustomEdge({
            id,
            sourceX,
            sourceY,
            targetX,
            targetY,
            sourcePosition,
            targetPosition,
            selected,
        }) {
            const [isHovered, setIsHovered] = useState(false);
            const removeConnection = useWorkflowStore((state) => state.removeConnection);

            const [edgePath, labelX, labelY] = getBezierPath({
                sourceX,
                sourceY,
                sourcePosition,
                targetX,
                targetY,
                targetPosition,
            });

            const showButtons = selected || isHovered;

            return React.createElement(React.Fragment, null, [
                // Invisible wider path for hover
                React.createElement('path', {
                    key: 'hover-path',
                    d: edgePath,
                    fill: 'none',
                    stroke: 'transparent',
                    strokeWidth: 20,
                    onMouseEnter: () => setIsHovered(true),
                    onMouseLeave: () => setIsHovered(false),
                }),
                // Visible edge
                React.createElement(BaseEdge, {
                    key: 'edge',
                    id,
                    path: edgePath,
                    style: {
                        stroke: selected ? '#667eea' : isHovered ? '#8a8aaa' : '#5a5a7a',
                        strokeWidth: selected ? 3 : 2,
                    },
                    markerEnd: 'url(#arrow)',
                }),
                // Delete button
                showButtons && React.createElement(EdgeLabelRenderer, { key: 'label' },
                    React.createElement('div', {
                        className: 'edge-button-container nodrag nopan',
                        style: {
                            transform: `translate(-50%, -50%) translate(${labelX}px, ${labelY}px)`,
                        },
                        onMouseEnter: () => setIsHovered(true),
                        onMouseLeave: () => setIsHovered(false),
                    },
                        React.createElement('button', {
                            className: 'edge-button',
                            onClick: (e) => {
                                e.stopPropagation();
                                removeConnection(id);
                            },
                            title: 'Delete connection',
                        }, '\u00d7')
                    )
                ),
            ]);
        });

        const nodeTypes = { custom: CustomNode };
        const edgeTypes = { custom: CustomEdge };

        // Expandable JSON Viewer Component
        // Shows JSON with expand/collapse on objects and arrays
        // expandAll: fully expand all nested items recursively
        // isFirstItem: auto-expand just this item (not children)
        function JsonViewer({ data, defaultExpanded = false, isFirstItem = false, expandAll = false }) {
            const [expanded, setExpanded] = useState(defaultExpanded || isFirstItem || expandAll);

            const handleToggle = (e) => {
                e.stopPropagation();
                setExpanded(!expanded);
            };

            if (data === null) return React.createElement('span', { className: 'json-null' }, 'null');
            if (data === undefined) return React.createElement('span', { className: 'json-undefined' }, 'undefined');

            const type = typeof data;

            if (type === 'string') {
                return React.createElement('span', { className: 'json-string' }, `"${data}"`);
            }
            if (type === 'number') {
                return React.createElement('span', { className: 'json-number' }, String(data));
            }
            if (type === 'boolean') {
                return React.createElement('span', { className: 'json-boolean' }, String(data));
            }

            if (Array.isArray(data)) {
                if (data.length === 0) {
                    return React.createElement('span', { className: 'json-bracket' }, '[]');
                }
                return React.createElement('div', { className: 'json-array' }, [
                    React.createElement('span', {
                        key: 'bracket-open',
                        className: 'json-bracket json-toggle',
                        onClick: handleToggle,
                        title: expanded ? 'Collapse' : 'Expand',
                    }, expanded ? '[' : `[${data.length} items...]`),
                    expanded && React.createElement('div', { key: 'items', className: 'json-indent' },
                        data.map((item, index) =>
                            React.createElement('div', { key: index, className: 'json-array-item' }, [
                                React.createElement(JsonViewer, {
                                    key: 'value',
                                    data: item,
                                    isFirstItem: !expandAll && index === 0,
                                    expandAll: expandAll,
                                }),
                                index < data.length - 1 && React.createElement('span', { key: 'comma', className: 'json-comma' }, ','),
                            ])
                        )
                    ),
                    expanded && React.createElement('span', { key: 'bracket-close', className: 'json-bracket' }, ']'),
                ]);
            }

            if (type === 'object') {
                const keys = Object.keys(data);
                if (keys.length === 0) {
                    return React.createElement('span', { className: 'json-bracket' }, '{}');
                }
                return React.createElement('div', { className: 'json-object' }, [
                    React.createElement('span', {
                        key: 'bracket-open',
                        className: 'json-bracket json-toggle',
                        onClick: handleToggle,
                        title: expanded ? 'Collapse' : 'Expand',
                    }, expanded ? '{' : `{${keys.length} keys...}`),
                    expanded && React.createElement('div', { key: 'props', className: 'json-indent' },
                        keys.map((key, index) =>
                            React.createElement('div', { key, className: 'json-property' }, [
                                React.createElement('span', { key: 'key', className: 'json-key' }, `"${key}"`),
                                React.createElement('span', { key: 'colon', className: 'json-colon' }, ': '),
                                React.createElement(JsonViewer, {
                                    key: 'value',
                                    data: data[key],
                                    expandAll: expandAll,
                                }),
                                index < keys.length - 1 && React.createElement('span', { key: 'comma', className: 'json-comma' }, ','),
                            ])
                        )
                    ),
                    expanded && React.createElement('span', { key: 'bracket-close', className: 'json-bracket' }, '}'),
                ]);
            }

            return React.createElement('span', null, String(data));
        }

        // Draggable JSON Viewer for Expression Editor
        // Allows dragging JSON paths to insert into expressions
        function DraggableJsonViewer({ data, path = [], defaultExpanded = false, isFirstItem = true, onDragPath }) {
            const [expanded, setExpanded] = useState(defaultExpanded || isFirstItem);

            const handleToggle = (e) => {
                e.stopPropagation();
                setExpanded(!expanded);
            };

            const handleDragStart = (e, currentPath) => {
                const pathStr = getJsonPath(data, currentPath);
                e.dataTransfer.setData('text/plain', `{{${pathStr}}}`);
                e.dataTransfer.effectAllowed = 'copy';
            };

            if (data === null) {
                return React.createElement('span', {
                    className: 'json-null json-draggable',
                    draggable: true,
                    onDragStart: (e) => handleDragStart(e, path),
                }, 'null');
            }
            if (data === undefined) return React.createElement('span', { className: 'json-undefined' }, 'undefined');

            const type = typeof data;

            if (type === 'string') {
                return React.createElement('span', {
                    className: 'json-string json-draggable',
                    draggable: true,
                    onDragStart: (e) => handleDragStart(e, path),
                }, `"${data}"`);
            }
            if (type === 'number') {
                return React.createElement('span', {
                    className: 'json-number json-draggable',
                    draggable: true,
                    onDragStart: (e) => handleDragStart(e, path),
                }, String(data));
            }
            if (type === 'boolean') {
                return React.createElement('span', {
                    className: 'json-boolean json-draggable',
                    draggable: true,
                    onDragStart: (e) => handleDragStart(e, path),
                }, String(data));
            }

            if (Array.isArray(data)) {
                if (data.length === 0) {
                    return React.createElement('span', { className: 'json-bracket' }, '[]');
                }
                return React.createElement('div', { className: 'json-array' }, [
                    React.createElement('span', {
                        key: 'bracket-open',
                        className: 'json-bracket json-toggle json-draggable',
                        onClick: handleToggle,
                        draggable: true,
                        onDragStart: (e) => handleDragStart(e, path),
                        title: expanded ? 'Collapse (drag to insert path)' : 'Expand (drag to insert path)',
                    }, expanded ? '[' : `[${data.length} items...]`),
                    expanded && React.createElement('div', { key: 'items', className: 'json-indent' },
                        data.map((item, index) =>
                            React.createElement('div', { key: index, className: 'json-array-item' }, [
                                React.createElement(DraggableJsonViewer, {
                                    key: 'value',
                                    data: item,
                                    path: [...path, index],
                                    isFirstItem: index === 0,
                                    onDragPath,
                                }),
                                index < data.length - 1 && React.createElement('span', { key: 'comma', className: 'json-comma' }, ','),
                            ])
                        )
                    ),
                    expanded && React.createElement('span', { key: 'bracket-close', className: 'json-bracket' }, ']'),
                ]);
            }

            if (type === 'object') {
                const keys = Object.keys(data);
                if (keys.length === 0) {
                    return React.createElement('span', { className: 'json-bracket' }, '{}');
                }
                return React.createElement('div', { className: 'json-object' }, [
                    React.createElement('span', {
                        key: 'bracket-open',
                        className: 'json-bracket json-toggle json-draggable',
                        onClick: handleToggle,
                        draggable: true,
                        onDragStart: (e) => handleDragStart(e, path),
                        title: expanded ? 'Collapse (drag to insert path)' : 'Expand (drag to insert path)',
                    }, expanded ? '{' : `{${keys.length} keys...}`),
                    expanded && React.createElement('div', { key: 'props', className: 'json-indent' },
                        keys.map((key, index) =>
                            React.createElement('div', { key, className: 'json-property' }, [
                                React.createElement('span', {
                                    key: 'key',
                                    className: 'json-key json-draggable',
                                    draggable: true,
                                    onDragStart: (e) => handleDragStart(e, [...path, key]),
                                    title: 'Drag to insert path',
                                }, `"${key}"`),
                                React.createElement('span', { key: 'colon', className: 'json-colon' }, ': '),
                                React.createElement(DraggableJsonViewer, {
                                    key: 'value',
                                    data: data[key],
                                    path: [...path, key],
                                    isFirstItem: false,
                                    onDragPath,
                                }),
                                index < keys.length - 1 && React.createElement('span', { key: 'comma', className: 'json-comma' }, ','),
                            ])
                        )
                    ),
                    expanded && React.createElement('span', { key: 'bracket-close', className: 'json-bracket' }, '}'),
                ]);
            }

            return React.createElement('span', null, String(data));
        }

        // Expression Editor Modal
        // Three panes: Input data (draggable), Expression editor, Live result
        function ExpressionEditorModal({ value, inputData, onSave, onClose }) {
            const [localValue, setLocalValue] = useState(value || '');
            const textareaRef = useRef(null);

            // Evaluate the template with input data
            const evaluation = useMemo(() => {
                // Use first item if array, otherwise use whole input
                const $ = Array.isArray(inputData) ? (inputData[0] || {}) : (inputData || {});
                return evaluateTemplate(localValue, $);
            }, [localValue, inputData]);

            const handleSave = () => {
                onSave(localValue);
                onClose();
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Escape') {
                    onClose();
                } else if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                    handleSave();
                }
            };

            // Handle drop from draggable JSON viewer
            const handleDrop = (e) => {
                e.preventDefault();
                const text = e.dataTransfer.getData('text/plain');
                if (text && textareaRef.current) {
                    const textarea = textareaRef.current;
                    const start = textarea.selectionStart;
                    const end = textarea.selectionEnd;
                    const newValue = localValue.substring(0, start) + text + localValue.substring(end);
                    setLocalValue(newValue);
                    // Set cursor after inserted text
                    setTimeout(() => {
                        textarea.focus();
                        textarea.selectionStart = textarea.selectionEnd = start + text.length;
                    }, 0);
                }
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            };

            // Render highlighted parts for the result pane
            const renderResultParts = () => {
                if (!evaluation.hasExpressions) {
                    return React.createElement('div', { className: 'expr-result-value' }, localValue || '(empty)');
                }

                return React.createElement('div', null, [
                    evaluation.parts.map((part, i) => {
                        if (part.type === 'text') {
                            return React.createElement('span', { key: i }, part.value);
                        } else {
                            if (part.error) {
                                return React.createElement('span', {
                                    key: i,
                                    className: 'expr-result-error',
                                    title: part.error,
                                }, `{{${part.value}}}`);
                            } else {
                                return React.createElement('span', {
                                    key: i,
                                    className: 'expr-result-value',
                                    style: { background: 'rgba(40, 167, 69, 0.2)', padding: '0 2px', borderRadius: '2px' },
                                }, part.evaluated);
                            }
                        }
                    }),
                    evaluation.result !== null && React.createElement('div', {
                        key: 'final',
                        style: { marginTop: '16px', paddingTop: '16px', borderTop: '1px solid #3a3a5e' },
                    }, [
                        React.createElement('div', { key: 'label', style: { fontSize: '10px', color: '#888', marginBottom: '4px' } }, 'FINAL RESULT'),
                        React.createElement('div', { key: 'value', className: 'expr-result-value' }, evaluation.result),
                    ]),
                ]);
            };

            return React.createElement('div', {
                className: 'expr-editor-overlay',
                onClick: onClose,
                onKeyDown: handleKeyDown,
            },
                React.createElement('div', {
                    className: 'expr-editor-dialog',
                    onClick: (e) => e.stopPropagation(),
                }, [
                    // Header
                    React.createElement('div', { key: 'header', className: 'expr-editor-header' }, [
                        React.createElement('h3', { key: 'title' }, 'Expression Editor'),
                        React.createElement('button', {
                            key: 'close',
                            className: 'expr-editor-close',
                            onClick: onClose,
                        }, ''),
                    ]),
                    // Body with three panes
                    React.createElement('div', { key: 'body', className: 'expr-editor-body' }, [
                        // Input pane - shows available data (draggable)
                        // For arrays (map node input), show first item since $ represents each item
                        React.createElement('div', { key: 'input', className: 'expr-editor-pane input-pane' }, [
                            React.createElement('div', { key: 'header', className: 'expr-pane-header' },
                                Array.isArray(inputData) && inputData.length > 1
                                    ? `Input Data - $ is each item (${inputData.length} items)`
                                    : 'Input Data (drag to insert)'
                            ),
                            React.createElement('div', { key: 'content', className: 'expr-pane-content' },
                                inputData
                                    ? React.createElement('div', { className: 'json-viewer' },
                                        React.createElement(DraggableJsonViewer, {
                                            // Show first item for arrays, since $ represents each item in map nodes
                                            data: Array.isArray(inputData) ? (inputData[0] || {}) : inputData,
                                            defaultExpanded: true,
                                        }))
                                    : React.createElement('div', { style: { color: '#555', fontStyle: 'italic' } }, 'No input data available')
                            ),
                        ]),
                        // Expression pane - editable textarea
                        React.createElement('div', { key: 'expr', className: 'expr-editor-pane expr-pane' }, [
                            React.createElement('div', { key: 'header', className: 'expr-pane-header' }, 'Expression'),
                            React.createElement('div', { key: 'content', className: 'expr-pane-content' },
                                React.createElement('textarea', {
                                    ref: textareaRef,
                                    className: 'expr-input-textarea',
                                    value: localValue,
                                    onChange: (e) => setLocalValue(e.target.value),
                                    onDrop: handleDrop,
                                    onDragOver: handleDragOver,
                                    placeholder: 'Enter value or expression like {{$.fieldName}}',
                                    autoFocus: true,
                                })
                            ),
                        ]),
                        // Result pane - live preview
                        React.createElement('div', { key: 'result', className: 'expr-editor-pane result-pane' }, [
                            React.createElement('div', { key: 'header', className: 'expr-pane-header' }, 'Live Result'),
                            React.createElement('div', { key: 'content', className: 'expr-pane-content expr-result-display' },
                                renderResultParts()
                            ),
                        ]),
                    ]),
                    // Footer
                    React.createElement('div', { key: 'footer', className: 'expr-editor-footer' }, [
                        React.createElement('button', {
                            key: 'cancel',
                            className: 'expr-editor-btn expr-editor-btn-cancel',
                            onClick: onClose,
                        }, 'Cancel'),
                        React.createElement('button', {
                            key: 'save',
                            className: 'expr-editor-btn expr-editor-btn-primary',
                            onClick: handleSave,
                        }, 'Save'),
                    ]),
                ])
            );
        }

        // Expression-enabled Input component
        // Shows colored {{...}} when not focused, plain input when focused
        function ExpressionInput({ value, onChange, onBlur, inputData, isTextarea, placeholder, className, rows }) {
            const [showEditor, setShowEditor] = useState(false);
            const [isFocused, setIsFocused] = useState(false);
            const inputRef = useRef(null);

            // Evaluate for highlighting
            const evaluation = useMemo(() => {
                const $ = Array.isArray(inputData) ? (inputData[0] || {}) : (inputData || {});
                return evaluateTemplate(value || '', $);
            }, [value, inputData]);

            const handleIndicatorClick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setShowEditor(true);
            };

            const handleSave = (newValue) => {
                onChange(newValue);
                if (onBlur) onBlur();
            };

            const handleBlur = () => {
                setIsFocused(false);
                if (onBlur) onBlur();
            };

            const handleDisplayClick = () => {
                setIsFocused(true);
                // Focus the input after render
                setTimeout(() => inputRef.current?.focus(), 0);
            };

            // Render colored content for display (when not focused)
            const renderColoredContent = () => {
                if (!value) {
                    return React.createElement('span', { style: { color: '#555' } }, placeholder || '');
                }
                if (!evaluation.hasExpressions) {
                    return value;
                }
                return evaluation.parts.map((part, i) => {
                    if (part.type === 'text') {
                        return React.createElement('span', { key: i }, part.value);
                    } else {
                        const color = part.error ? '#e74c3c' : '#28a745';
                        return React.createElement('span', { key: i, style: { color } }, part.raw);
                    }
                });
            };

            const baseClass = isTextarea ? 'property-textarea' : 'property-input';

            return React.createElement('div', {
                className: 'expr-input-wrapper',
                style: { position: 'relative' },
            }, [
                // When not focused: show colored display
                !isFocused && React.createElement('div', {
                    key: 'display',
                    className: baseClass,
                    style: {
                        cursor: 'text',
                        minHeight: isTextarea ? '120px' : 'auto',
                        whiteSpace: isTextarea ? 'pre-wrap' : 'nowrap',
                        overflow: 'hidden',
                    },
                    onClick: handleDisplayClick,
                }, renderColoredContent()),
                // When focused: show actual input/textarea
                isFocused && (isTextarea
                    ? React.createElement('textarea', {
                        key: 'input',
                        ref: inputRef,
                        className: baseClass,
                        value: value || '',
                        placeholder: placeholder,
                        rows: rows || 8,
                        onChange: (e) => onChange(e.target.value),
                        onBlur: handleBlur,
                        autoFocus: true,
                    })
                    : React.createElement('input', {
                        key: 'input',
                        ref: inputRef,
                        type: 'text',
                        className: baseClass,
                        value: value || '',
                        placeholder: placeholder,
                        onChange: (e) => onChange(e.target.value),
                        onBlur: handleBlur,
                        autoFocus: true,
                    })
                ),
                // Green triangle indicator
                React.createElement('div', {
                    key: 'indicator',
                    className: `expr-indicator${evaluation.hasErrors ? ' has-error' : ''}`,
                    onClick: handleIndicatorClick,
                    title: 'Open expression editor',
                }),
                // Expression editor modal
                showEditor && React.createElement(ExpressionEditorModal, {
                    key: 'modal',
                    value: value,
                    inputData: inputData,
                    onSave: handleSave,
                    onClose: () => setShowEditor(false),
                }),
            ]);
        }

        // Property Editor Components
        function TextPropertyEditor({ property, onChange, inputData }) {
            const [value, setValue] = useState(property.value);
            const valueRef = useRef(value);

            const handleChange = (newValue) => {
                setValue(newValue);
                valueRef.current = newValue;
            };

            const handleBlur = () => {
                if (valueRef.current !== property.value) {
                    onChange(property.id, valueRef.current);
                }
            };

            return React.createElement('div', { className: 'property-group' }, [
                React.createElement('label', { key: 'label', className: 'property-label' }, property.label),
                React.createElement(ExpressionInput, {
                    key: 'input',
                    value: value,
                    onChange: handleChange,
                    onBlur: handleBlur,
                    inputData: inputData,
                    placeholder: property.placeholder || '',
                }),
            ]);
        }

        function TextareaPropertyEditor({ property, onChange, inputData }) {
            const [value, setValue] = useState(property.value);
            const valueRef = useRef(value);

            const handleChange = (newValue) => {
                setValue(newValue);
                valueRef.current = newValue;
            };

            const handleBlur = () => {
                if (valueRef.current !== property.value) {
                    onChange(property.id, valueRef.current);
                }
            };

            return React.createElement('div', { className: 'property-group' }, [
                React.createElement('label', { key: 'label', className: 'property-label' }, property.label),
                property.instructions && React.createElement('div', {
                    key: 'instructions',
                    className: 'property-instructions',
                }, property.instructions),
                React.createElement(ExpressionInput, {
                    key: 'textarea',
                    value: value,
                    onChange: handleChange,
                    onBlur: handleBlur,
                    inputData: inputData,
                    isTextarea: true,
                    placeholder: property.placeholder || '',
                    rows: 8,
                }),
            ]);
        }

        function NumberPropertyEditor({ property, onChange }) {
            const [value, setValue] = useState(property.value);

            const handleBlur = () => {
                const numValue = Number(value);
                if (!isNaN(numValue) && numValue !== property.value) {
                    onChange(property.id, numValue);
                }
            };

            return React.createElement('div', { className: 'property-group' }, [
                React.createElement('label', { key: 'label', className: 'property-label' }, property.label),
                React.createElement('input', {
                    key: 'input',
                    type: 'number',
                    className: 'property-input',
                    value: value,
                    min: property.min,
                    max: property.max,
                    onChange: (e) => setValue(e.target.value),
                    onBlur: handleBlur,
                }),
            ]);
        }

        function SelectPropertyEditor({ property, onChange }) {
            return React.createElement('div', { className: 'property-group' }, [
                React.createElement('label', { key: 'label', className: 'property-label' }, property.label),
                React.createElement('select', {
                    key: 'select',
                    className: 'property-select',
                    value: property.value,
                    onChange: (e) => onChange(property.id, e.target.value),
                },
                    property.options.map((opt) =>
                        React.createElement('option', { key: opt.value, value: opt.value }, opt.label)
                    )
                ),
            ]);
        }

        function FieldListPropertyEditor({ property, onChange, inputData }) {
            const fields = property.value || [];

            const handleFieldChange = (index, key, value) => {
                const newFields = [...fields];
                newFields[index] = { ...newFields[index], [key]: value };
                onChange(property.id, newFields);
            };

            const handleAddField = () => {
                onChange(property.id, [...fields, { name: '', value: '' }]);
            };

            const handleDeleteField = (index) => {
                const newFields = fields.filter((_, i) => i !== index);
                onChange(property.id, newFields);
            };

            const plusIcon = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>`;

            return React.createElement('div', { className: 'property-group' }, [
                React.createElement('label', { key: 'label', className: 'property-label' }, property.label),
                React.createElement('div', { key: 'list', className: 'field-list' }, [
                    ...fields.map((field, index) =>
                        React.createElement('div', { key: index, className: 'field-item' }, [
                            React.createElement('div', { key: 'inputs', className: 'field-item-inputs' }, [
                                React.createElement('div', { key: 'name-row', className: 'field-item-row' }, [
                                    React.createElement('label', { key: 'label' }, 'Name'),
                                    React.createElement('div', { key: 'input', style: { flex: 1 } },
                                        React.createElement(ExpressionInput, {
                                            value: field.name || '',
                                            onChange: (val) => handleFieldChange(index, 'name', val),
                                            inputData: inputData,
                                            placeholder: 'field name',
                                        })
                                    ),
                                ]),
                                React.createElement('div', { key: 'value-row', className: 'field-item-row' }, [
                                    React.createElement('label', { key: 'label' }, 'Value'),
                                    React.createElement('div', { key: 'input', style: { flex: 1 } },
                                        React.createElement(ExpressionInput, {
                                            value: field.value || '',
                                            onChange: (val) => handleFieldChange(index, 'value', val),
                                            inputData: inputData,
                                            placeholder: 'value (JSON or expression)',
                                        })
                                    ),
                                ]),
                            ]),
                            React.createElement('button', {
                                key: 'delete',
                                className: 'field-delete-btn',
                                onClick: () => handleDeleteField(index),
                                title: 'Remove field',
                            }, ''),
                        ])
                    ),
                    React.createElement('button', {
                        key: 'add',
                        className: 'add-field-btn',
                        onClick: handleAddField,
                        'data-testid': 'add-field-btn',
                    }, [
                        React.createElement('span', {
                            key: 'icon',
                            dangerouslySetInnerHTML: { __html: plusIcon },
                        }),
                        'Add Field',
                    ]),
                ]),
            ]);
        }

        function DynamicSelectPropertyEditor({ property, onChange, nodeTypeId, credentialName, nodeData }) {
            const [options, setOptions] = useState([]);
            const [hasFetched, setHasFetched] = useState(false);

            // Fetch options immediately on mount and when dependencies change
            // Backend returns cached data instantly, refreshes in background if stale
            const fetchOptions = async () => {
                try {
                    const response = await fetch('/api/dynamic-enum', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            nodeTypeId,
                            enumKey: property.enumKey,
                            nodeData,
                            credentialName,
                        }),
                    });
                    if (response.ok) {
                        const data = await response.json();
                        setOptions(data.options || []);
                    }
                } catch (e) {
                    console.error('Failed to load options:', e);
                }
            };

            // Fetch on mount and when dependencies change
            useEffect(() => {
                fetchOptions();
            }, [credentialName, JSON.stringify(nodeData), property.enumKey]);

            // Also refetch when dropdown is focused (to pick up background refreshes)
            const handleFocus = () => {
                if (hasFetched) {
                    fetchOptions();  // Silently refresh
                }
                setHasFetched(true);
            };

            return React.createElement('div', { className: 'property-group' }, [
                React.createElement('label', { key: 'label', className: 'property-label' }, property.label),
                React.createElement('select', {
                    key: 'select',
                    className: 'property-select',
                    value: property.value || '',
                    onChange: (e) => onChange(property.id, e.target.value),
                    onFocus: handleFocus,
                }, [
                    React.createElement('option', { key: '__placeholder', value: '' }, 'Select a value'),
                    ...options.map((opt) =>
                        React.createElement('option', { key: opt.value, value: opt.value }, opt.label)
                    ),
                ]),
            ]);
        }

        function PropertyEditor({ property, onChange, inputData, nodeTypeId, credentialName, nodeData }) {
            switch (property.type) {
                case 'text':
                    return React.createElement(TextPropertyEditor, { property, onChange, inputData });
                case 'textarea':
                    return React.createElement(TextareaPropertyEditor, { property, onChange, inputData });
                case 'number':
                    return React.createElement(NumberPropertyEditor, { property, onChange });
                case 'select':
                    return React.createElement(SelectPropertyEditor, { property, onChange });
                case 'dynamicSelect':
                    return React.createElement(DynamicSelectPropertyEditor, {
                        property, onChange, nodeTypeId, credentialName, nodeData
                    });
                case 'fieldlist':
                    return React.createElement(FieldListPropertyEditor, { property, onChange, inputData });
                default:
                    return null;
            }
        }

        // Output Editor Modal - for editing pinned node output
        function OutputEditorModal({ value, onSave, onClose }) {
            const [localValue, setLocalValue] = useState(() => {
                try {
                    return JSON.stringify(value, null, 2);
                } catch {
                    return '{}';
                }
            });
            const [error, setError] = useState(null);

            const handleSave = () => {
                try {
                    const parsed = JSON.parse(localValue);
                    onSave(parsed);
                    onClose();
                } catch (e) {
                    setError('Invalid JSON: ' + e.message);
                }
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Escape') {
                    onClose();
                } else if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    handleSave();
                }
            };

            return React.createElement('div', {
                className: 'expr-editor-overlay',
                onClick: onClose,
                onKeyDown: handleKeyDown,
            },
                React.createElement('div', {
                    className: 'expr-editor-dialog',
                    style: { width: '600px', maxWidth: '90vw' },
                    onClick: (e) => e.stopPropagation(),
                }, [
                    React.createElement('div', { key: 'header', className: 'expr-editor-header' }, [
                        React.createElement('h3', { key: 'title' }, 'Edit Pinned Output'),
                        React.createElement('button', {
                            key: 'close',
                            className: 'expr-editor-close',
                            onClick: onClose,
                        }, ''),
                    ]),
                    React.createElement('div', { key: 'body', style: { padding: '16px' } }, [
                        React.createElement('textarea', {
                            key: 'editor',
                            className: 'property-textarea',
                            style: {
                                width: '100%',
                                height: '400px',
                                fontFamily: 'monospace',
                                fontSize: '13px',
                            },
                            value: localValue,
                            onChange: (e) => {
                                setLocalValue(e.target.value);
                                setError(null);
                            },
                            autoFocus: true,
                        }),
                        error && React.createElement('div', {
                            key: 'error',
                            style: { color: '#e74c3c', marginTop: '8px', fontSize: '12px' },
                        }, error),
                    ]),
                    React.createElement('div', {
                        key: 'footer',
                        style: {
                            padding: '12px 16px',
                            borderTop: '1px solid #3a3a5e',
                            display: 'flex',
                            justifyContent: 'flex-end',
                            gap: '8px',
                        },
                    }, [
                        React.createElement('button', {
                            key: 'cancel',
                            className: 'toolbar-btn',
                            onClick: onClose,
                        }, 'Cancel'),
                        React.createElement('button', {
                            key: 'save',
                            className: 'execute-btn',
                            onClick: handleSave,
                        }, 'Save'),
                    ]),
                ])
            );
        }

        // Node Editor Dialog
        function NodeEditorDialog({ nodeId, onClose }) {
            const node = useWorkflowStore((state) => state.nodes.find((n) => n.id === nodeId));
            const connections = useWorkflowStore((state) => state.connections);
            const updateNodeData = useWorkflowStore((state) => state.updateNodeData);
            const updateNodeName = useWorkflowStore((state) => state.updateNodeName);
            const isNameUnique = useWorkflowStore((state) => state.isNameUnique);
            const setNodeExecution = useWorkflowStore((state) => state.setNodeExecution);
            const ambientExecution = useWorkflowStore((state) => state.ambientExecution);
            const isReadOnly = useWorkflowStore((state) => state.isReadOnly);

            const [localName, setLocalName] = useState(node?.name || '');
            const [nameError, setNameError] = useState(false);
            const [showOutputEditor, setShowOutputEditor] = useState(false);

            if (!node) return null;

            // Pin state from node data
            const isPinned = node.data?.pinned || false;
            const pinnedOutput = node.data?.pinnedOutput;

            const nodeType = nodeTypeDefinitions[node.typeId];
            if (!nodeType) return null;

            // Find input from upstream nodes
            // Look at connections where this node is the target
            const incomingConnections = connections.filter(c => c.targetNodeId === nodeId);
            let upstreamData = null;
            for (const conn of incomingConnections) {
                const sourceExecution = ambientExecution[conn.sourceNodeId];
                if (sourceExecution?.output) {
                    upstreamData = sourceExecution.output;
                    break; // Use first found input
                }
            }

            // Get execution data from ambient execution
            const nodeExecution = ambientExecution[nodeId];
            const nodeOutput = nodeExecution?.nodeOutput || null; // What THIS node produced
            const fullOutput = nodeExecution?.output || null; // Combined output (input + nodeOutput under node name)
            const executionTime = nodeExecution?.executedAt
                ? new Date(nodeExecution.executedAt).toLocaleTimeString()
                : null;

            const properties = nodeType.getProperties(node.data);

            // Build combined output like the executor does: {...input, [nodeName]: nodeOutput}
            const buildCombinedOutput = (rawOutput) => {
                if (!rawOutput) return null;
                const outputArray = Array.isArray(rawOutput) ? rawOutput : [rawOutput];
                return outputArray.map((out, i) => {
                    const inp = (upstreamData && upstreamData[i]) || {};
                    return { ...inp, [node.name]: out };
                });
            };

            const handlePropertyChange = (propertyId, value) => {
                updateNodeData(nodeId, { [propertyId]: value });
            };

            const handleNameBlur = () => {
                const trimmedName = localName.trim();
                if (trimmedName && trimmedName !== node.name) {
                    if (isNameUnique(trimmedName, nodeId)) {
                        updateNodeName(nodeId, trimmedName);
                        setNameError(false);
                    } else {
                        setNameError(true);
                    }
                } else if (!trimmedName) {
                    setLocalName(node.name);
                }
            };

            // Pin/unpin the current output
            const handlePin = () => {
                if (!fullOutput) return;
                updateNodeData(nodeId, { pinned: true, pinnedOutput: fullOutput });
                // Update ambient execution so downstream nodes see the pinned output
                setNodeExecution(nodeId, upstreamData, nodeOutput, fullOutput);
            };

            const handleUnpin = () => {
                updateNodeData(nodeId, { pinned: false, pinnedOutput: undefined });
                // Clear ambient execution - node will need to be re-executed
                setNodeExecution(nodeId, null, null, null);
            };

            // Edit pinned output - auto-pins first if not pinned
            const handleEdit = () => {
                if (!isPinned) {
                    // Auto-pin with current output or empty default
                    const output = fullOutput || buildCombinedOutput([{}]);
                    updateNodeData(nodeId, { pinned: true, pinnedOutput: output });
                    // Update ambient execution
                    setNodeExecution(nodeId, upstreamData, nodeOutput, output);
                }
                setShowOutputEditor(true);
            };

            // Save edited output - user edits the full combined output
            const handleSaveOutput = (newOutput) => {
                // Ensure it's an array
                const output = Array.isArray(newOutput) ? newOutput : [newOutput];
                updateNodeData(nodeId, { pinnedOutput: output });
                // Update ambient execution with the new pinned output
                setNodeExecution(nodeId, upstreamData, output, output);
            };

            // Execute a node via server API
            // Server handles upstream execution, expression evaluation, etc.
            const [isExecuting, setIsExecuting] = useState(false);

            const handleExecute = async () => {
                if (isExecuting) return;
                setIsExecuting(true);

                try {
                    const store = useWorkflowStore.getState();
                    const response = await fetch('/api/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            node_id: nodeId,
                            workflow: { nodes: store.nodes, connections: store.connections },
                            execution: store.ambientExecution,
                        }),
                    });

                    if (!response.ok) {
                        // Try to get error details from response
                        let errorMsg = `HTTP ${response.status}: ${response.statusText}`;
                        try {
                            const errorBody = await response.text();
                            if (errorBody) errorMsg += `\n${errorBody}`;
                        } catch {}
                        console.error('Execute failed:', errorMsg);
                        // Store error in execution so it displays
                        store.setNodeExecution(
                            nodeId,
                            null,
                            [{ error: errorMsg }],
                            [{ error: errorMsg }]
                        );
                        return;
                    }

                    const result = await response.json();

                    // Update all execution results from server
                    // Server may have executed upstream nodes too
                    for (const [execNodeId, execData] of Object.entries(result.execution)) {
                        store.setNodeExecution(
                            execNodeId,
                            execData.input,
                            execData.nodeOutput,
                            execData.output
                        );
                    }
                } catch (err) {
                    console.error('Execute error:', err);
                    // Store error in execution so it displays
                    const store = useWorkflowStore.getState();
                    store.setNodeExecution(
                        nodeId,
                        null,
                        [{ error: String(err) }],
                        [{ error: String(err) }]
                    );
                } finally {
                    setIsExecuting(false);
                }
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Escape') {
                    onClose();
                }
            };

            // Play icon SVG
            const playIcon = `<svg viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"/></svg>`;

            return React.createElement('div', {
                className: 'node-editor-overlay',
                onClick: onClose,
                onKeyDown: handleKeyDown,
            },
                React.createElement('div', {
                    className: 'node-editor-dialog',
                    onClick: (e) => e.stopPropagation(),
                }, [
                    // Header
                    React.createElement('div', { key: 'header', className: 'node-editor-header' }, [
                        React.createElement('h2', { key: 'title' }, [
                            React.createElement('span', {
                                key: 'icon',
                                className: 'node-icon',
                                dangerouslySetInnerHTML: { __html: nodeType.icon },
                            }),
                            `Edit ${nodeType.name} Node`,
                        ]),
                        React.createElement('div', { key: 'actions', style: { display: 'flex', alignItems: 'center', gap: '12px' } }, [
                            !isReadOnly && React.createElement('button', {
                                key: 'execute',
                                className: 'execute-btn',
                                onClick: handleExecute,
                                disabled: isExecuting,
                                'data-testid': 'execute-btn',
                            }, [
                                React.createElement('span', {
                                    key: 'icon',
                                    dangerouslySetInnerHTML: { __html: playIcon },
                                }),
                                isExecuting ? 'Executing...' : 'Execute',
                            ]),
                            React.createElement('button', {
                                key: 'close',
                                className: 'node-editor-close',
                                onClick: onClose,
                            }, ''),
                        ]),
                    ]),
                    // Body with three panes
                    React.createElement('div', { key: 'body', className: 'node-editor-body' }, [
                        // Input pane - shows data from upstream nodes
                        // First item fully expanded, rest collapsed
                        React.createElement('div', { key: 'input', className: 'node-editor-pane input-pane' }, [
                            React.createElement('div', { key: 'header', className: 'pane-header' }, 'Input'),
                            React.createElement('div', { key: 'content', className: 'pane-content' },
                                upstreamData
                                    ? React.createElement('div', {
                                        key: 'input-content',
                                        className: 'json-viewer',
                                        'data-testid': 'execution-input',
                                    }, Array.isArray(upstreamData) && upstreamData.length > 0
                                        ? React.createElement('div', { className: 'json-array' }, [
                                            React.createElement('span', { key: 'open', className: 'json-bracket' }, '['),
                                            React.createElement('div', { key: 'items', className: 'json-indent' },
                                                upstreamData.map((item, index) =>
                                                    React.createElement('div', { key: index, className: 'json-array-item' }, [
                                                        React.createElement(JsonViewer, {
                                                            key: 'value',
                                                            data: item,
                                                            expandAll: index === 0, // Only first item fully expanded
                                                        }),
                                                        index < upstreamData.length - 1 && React.createElement('span', { key: 'comma', className: 'json-comma' }, ','),
                                                    ])
                                                )
                                            ),
                                            React.createElement('span', { key: 'close', className: 'json-bracket' }, ']'),
                                        ])
                                        : React.createElement(JsonViewer, { data: upstreamData, expandAll: true })
                                    )
                                    : React.createElement('div', { className: 'no-data-message' }, 'No input data available')
                            ),
                        ]),
                        // Editor pane
                        React.createElement('div', { key: 'editor', className: 'node-editor-pane editor-pane' }, [
                            React.createElement('div', { key: 'header', className: 'pane-header' }, 'Properties'),
                            React.createElement('div', { key: 'content', className: 'pane-content' }, [
                                // Name property (common to all nodes)
                                React.createElement('div', { key: 'name-group', className: 'property-group' }, [
                                    React.createElement('label', { key: 'label', className: 'property-label' }, 'Name'),
                                    React.createElement('input', {
                                        key: 'input',
                                        type: 'text',
                                        className: `property-input${nameError ? ' error' : ''}`,
                                        value: localName,
                                        onChange: (e) => setLocalName(e.target.value),
                                        onBlur: handleNameBlur,
                                    }),
                                    nameError && React.createElement('div', {
                                        key: 'error',
                                        className: 'property-description',
                                        style: { color: '#e74c3c' },
                                    }, 'Name must be unique'),
                                ]),
                                // Node-specific properties
                                ...properties.map((prop) =>
                                    React.createElement(PropertyEditor, {
                                        key: prop.id,
                                        property: prop,
                                        onChange: handlePropertyChange,
                                        inputData: upstreamData,
                                        nodeTypeId: node.typeId,
                                        credentialName: node.data.credentialName,
                                        nodeData: node.data,
                                    })
                                ),
                            ]),
                        ]),
                        // Output pane - shows what THIS node produced (not the combined result)
                        // All items fully expanded
                        React.createElement('div', { key: 'output', className: 'node-editor-pane output-pane' }, [
                            React.createElement('div', {
                                key: 'header',
                                className: 'pane-header',
                                style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center' },
                            }, [
                                React.createElement('span', { key: 'title' }, [
                                    'Output',
                                    isPinned && React.createElement('span', {
                                        key: 'pinned-badge',
                                        style: {
                                            marginLeft: '8px',
                                            fontSize: '10px',
                                            background: '#5b8def',
                                            color: '#fff',
                                            padding: '2px 6px',
                                            borderRadius: '4px',
                                            fontWeight: 'normal',
                                        },
                                    }, ' PINNED'),
                                ]),
                                !isReadOnly && React.createElement('div', {
                                    key: 'actions',
                                    style: { display: 'flex', gap: '4px' },
                                }, [
                                    // Edit button - always available
                                    React.createElement('button', {
                                        key: 'edit',
                                        className: 'toolbar-btn',
                                        style: { padding: '2px 8px', fontSize: '11px' },
                                        onClick: handleEdit,
                                        title: isPinned ? 'Edit pinned output' : 'Pin and edit output',
                                    }, ' Edit'),
                                    // Pin/Unpin button
                                    isPinned
                                        ? React.createElement('button', {
                                            key: 'unpin',
                                            className: 'toolbar-btn',
                                            style: { padding: '2px 8px', fontSize: '11px' },
                                            onClick: handleUnpin,
                                            title: 'Unpin output',
                                        }, ' Unpin')
                                        : React.createElement('button', {
                                            key: 'pin',
                                            className: 'toolbar-btn',
                                            style: { padding: '2px 8px', fontSize: '11px' },
                                            onClick: handlePin,
                                            disabled: !fullOutput,
                                            title: fullOutput ? 'Pin current output' : 'Execute node first to pin output',
                                        }, ' Pin'),
                                ]),
                            ]),
                            React.createElement('div', { key: 'content', className: 'pane-content' },
                                // Show pinned output if pinned, otherwise show execution output
                                isPinned && pinnedOutput
                                    ? React.createElement('div', { key: 'pinned-content' }, [
                                        React.createElement('div', {
                                            key: 'info',
                                            style: { fontSize: '11px', color: '#888', marginBottom: '8px' },
                                        }, 'This output is pinned. The node will return this value without executing.'),
                                        React.createElement('div', {
                                            key: 'json',
                                            className: 'json-viewer',
                                            'data-testid': 'execution-output',
                                        }, React.createElement(JsonViewer, { data: pinnedOutput, expandAll: true })),
                                    ])
                                    : fullOutput
                                        ? React.createElement('div', { key: 'output-content' }, [
                                            executionTime && React.createElement('div', {
                                                key: 'time',
                                                className: 'execution-time',
                                            }, `Executed at ${executionTime}`),
                                            React.createElement('div', {
                                                key: 'json',
                                                className: 'json-viewer',
                                                'data-testid': 'execution-output',
                                            }, React.createElement(JsonViewer, { data: fullOutput, expandAll: true })),
                                        ])
                                        : React.createElement('div', { className: 'no-data-message' }, 'No output data available')
                            ),
                        ]),
                    ]),
                    // Output editor modal
                    showOutputEditor && React.createElement(OutputEditorModal, {
                        key: 'output-editor',
                        value: pinnedOutput || fullOutput || buildCombinedOutput([{}]),
                        onSave: handleSaveOutput,
                        onClose: () => setShowOutputEditor(false),
                    }),
                ])
            );
        }

        // JSON Modal Component
        function JsonModal({ isOpen, onClose, json }) {
            if (!isOpen) return null;

            const handleCopy = () => {
                navigator.clipboard.writeText(json);
            };

            return React.createElement('div', {
                className: 'json-modal-overlay',
                onClick: onClose,
            },
                React.createElement('div', {
                    className: 'json-modal',
                    onClick: (e) => e.stopPropagation(),
                }, [
                    React.createElement('div', { key: 'header', className: 'json-modal-header' }, [
                        React.createElement('h3', { key: 'title' }, 'Workflow JSON'),
                        React.createElement('button', {
                            key: 'close',
                            className: 'json-modal-close',
                            onClick: onClose,
                        }, ''),
                    ]),
                    React.createElement('div', { key: 'body', className: 'json-modal-body' },
                        React.createElement('pre', null, json)
                    ),
                    React.createElement('div', { key: 'footer', className: 'json-modal-footer' },
                        React.createElement('button', {
                            className: 'json-modal-btn json-modal-btn-primary',
                            onClick: handleCopy,
                        }, 'Copy to Clipboard')
                    ),
                ])
            );
        }

        // WorkflowsTab Component
        function WorkflowsTab() {
            const dashboardPath = useWorkflowStore((state) => state.dashboardPath);
            const dashboardItems = useWorkflowStore((state) => state.dashboardItems);
            const dashboardLoading = useWorkflowStore((state) => state.dashboardLoading);
            const loadDashboardItems = useWorkflowStore((state) => state.loadDashboardItems);
            const loadWorkflow = useWorkflowStore((state) => state.loadWorkflow);
            const [openMenu, setOpenMenu] = useState(null);
            const [dragOver, setDragOver] = useState(null);

            useEffect(() => {
                loadDashboardItems(dashboardPath);
            }, []);

            const handleNewWorkflow = async () => {
                const name = window.prompt('Enter workflow name:');
                if (!name) return;
                try {
                    const response = await fetch('/api/workflows/new', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name, folder: dashboardPath }),
                    });
                    if (response.ok) {
                        const data = await response.json();
                        loadWorkflow(data.path);
                    } else {
                        const error = await response.json();
                        window.alert(error.detail || 'Failed to create workflow');
                    }
                } catch (err) {
                    console.error('Failed to create workflow:', err);
                }
            };

            const handleNewFolder = async () => {
                const name = window.prompt('Enter folder name:');
                if (!name) return;
                try {
                    const response = await fetch('/api/folders/new', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name, parent: dashboardPath }),
                    });
                    if (response.ok) {
                        loadDashboardItems(dashboardPath);
                    } else {
                        const error = await response.json();
                        window.alert(error.detail || 'Failed to create folder');
                    }
                } catch (err) {
                    console.error('Failed to create folder:', err);
                }
            };

            const handleDragStart = (e, item) => {
                if (item.type !== 'workflow') return;
                e.dataTransfer.setData('text/plain', item.path);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDragOver = (e, item) => {
                if (item.type !== 'folder') return;
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                setDragOver(item.path);
            };

            const handleDragLeave = () => {
                setDragOver(null);
            };

            const handleDrop = async (e, targetFolder) => {
                e.preventDefault();
                setDragOver(null);
                const sourcePath = e.dataTransfer.getData('text/plain');
                if (!sourcePath) return;

                try {
                    const response = await fetch(`/api/workflow/${sourcePath}/move`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ destination: targetFolder.path }),
                    });
                    if (response.ok) {
                        loadDashboardItems(dashboardPath);
                    } else {
                        const error = await response.json();
                        window.alert(error.detail || 'Failed to move workflow');
                    }
                } catch (err) {
                    console.error('Failed to move workflow:', err);
                }
            };

            // Close menu when clicking outside
            useEffect(() => {
                const handleClickOutside = () => setOpenMenu(null);
                if (openMenu) {
                    document.addEventListener('click', handleClickOutside);
                    return () => document.removeEventListener('click', handleClickOutside);
                }
            }, [openMenu]);

            const handleFolderClick = (path) => {
                loadDashboardItems(path);
            };

            const handleWorkflowDoubleClick = (path) => {
                loadWorkflow(path);
            };

            const handleUpClick = () => {
                const parts = dashboardPath.split('/').filter(Boolean);
                parts.pop();
                loadDashboardItems(parts.join('/'));
            };

            const handleMenuClick = (e, path) => {
                e.stopPropagation();
                setOpenMenu(openMenu === path ? null : path);
            };

            const handleExecuteClick = async (e, path) => {
                e.stopPropagation();
                setOpenMenu(null);
                try {
                    const response = await fetch(`/api/workflow/${path}/queue`, { method: 'POST' });
                    if (response.ok) {
                        const data = await response.json();
                        console.log('Workflow queued:', data.queue_id);
                    }
                } catch (err) {
                    console.error('Failed to queue workflow:', err);
                }
            };

            const handleToggleEnabled = async (e, item) => {
                e.stopPropagation();
                const newEnabled = !item.enabled;
                try {
                    const response = await fetch(`/api/workflow/${item.path}/enabled`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ enabled: newEnabled }),
                    });
                    if (response.ok) {
                        // Reload to get updated state
                        loadDashboardItems(dashboardPath);
                    }
                } catch (err) {
                    console.error('Failed to toggle enabled:', err);
                }
            };

            const folderIcon = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>';
            const fileIcon = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>';
            const menuIcon = '<svg viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="5" r="2"/><circle cx="12" cy="12" r="2"/><circle cx="12" cy="19" r="2"/></svg>';

            if (dashboardLoading) {
                return React.createElement('div', { className: 'empty-state' }, 'Loading...');
            }

            const plusIcon = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>';

            if (dashboardItems.length === 0 && !dashboardPath) {
                return React.createElement('div', { 'data-testid': 'workflows-tab' }, [
                    React.createElement('div', { key: 'toolbar', className: 'workflows-toolbar' }, [
                        React.createElement('button', {
                            key: 'new-workflow',
                            className: 'toolbar-btn',
                            onClick: handleNewWorkflow,
                            'data-testid': 'new-workflow-btn',
                        }, [
                            React.createElement('span', {
                                key: 'icon',
                                className: 'toolbar-btn-icon',
                                dangerouslySetInnerHTML: { __html: plusIcon },
                            }),
                            'New Workflow',
                        ]),
                        React.createElement('button', {
                            key: 'new-folder',
                            className: 'toolbar-btn',
                            onClick: handleNewFolder,
                            'data-testid': 'new-folder-btn',
                        }, [
                            React.createElement('span', {
                                key: 'icon',
                                className: 'toolbar-btn-icon',
                                dangerouslySetInnerHTML: { __html: plusIcon },
                            }),
                            'New Folder',
                        ]),
                    ]),
                    React.createElement('div', { key: 'empty', className: 'empty-state', 'data-testid': 'empty-state' },
                        'No workflows yet. Create your first workflow!'
                    ),
                ]);
            }

            return React.createElement('div', { 'data-testid': 'workflows-tab' }, [
                React.createElement('div', { key: 'toolbar', className: 'workflows-toolbar' }, [
                    React.createElement('button', {
                        key: 'new-workflow',
                        className: 'toolbar-btn',
                        onClick: handleNewWorkflow,
                        'data-testid': 'new-workflow-btn',
                    }, [
                        React.createElement('span', {
                            key: 'icon',
                            className: 'toolbar-btn-icon',
                            dangerouslySetInnerHTML: { __html: plusIcon },
                        }),
                        'New Workflow',
                    ]),
                    React.createElement('button', {
                        key: 'new-folder',
                        className: 'toolbar-btn',
                        onClick: handleNewFolder,
                        'data-testid': 'new-folder-btn',
                    }, [
                        React.createElement('span', {
                            key: 'icon',
                            className: 'toolbar-btn-icon',
                            dangerouslySetInnerHTML: { __html: plusIcon },
                        }),
                        'New Folder',
                    ]),
                ]),
                React.createElement('div', { key: 'list', className: 'file-list', 'data-testid': 'file-list' }, [
                    dashboardPath && React.createElement('div', {
                        key: 'up',
                        className: 'file-item folder',
                        onClick: handleUpClick,
                        'data-testid': 'folder-up',
                    }, [
                        React.createElement('div', {
                            key: 'icon',
                            className: 'file-item-icon',
                            dangerouslySetInnerHTML: { __html: folderIcon },
                        }),
                        React.createElement('span', { key: 'name', className: 'file-item-name' }, '..'),
                    ]),
                    ...dashboardItems.map((item) =>
                        React.createElement('div', {
                            key: item.path,
                            className: `file-item ${item.type}${dragOver === item.path ? ' drag-over' : ''}`,
                            onClick: item.type === 'folder' ? () => handleFolderClick(item.path) : undefined,
                            onDoubleClick: item.type === 'workflow' ? () => handleWorkflowDoubleClick(item.path) : undefined,
                            draggable: item.type === 'workflow',
                            onDragStart: (e) => handleDragStart(e, item),
                            onDragOver: (e) => handleDragOver(e, item),
                            onDragLeave: handleDragLeave,
                            onDrop: (e) => handleDrop(e, item),
                            'data-testid': `file-item-${item.name}`,
                        }, [
                        React.createElement('div', {
                            key: 'icon',
                            className: 'file-item-icon',
                            dangerouslySetInnerHTML: { __html: item.type === 'folder' ? folderIcon : fileIcon },
                        }),
                        React.createElement('span', { key: 'name', className: 'file-item-name' },
                            item.type === 'workflow' ? item.name.replace(/\.json$/, '') : item.name
                        ),
                        item.type === 'workflow' && item.stats && React.createElement('div', {
                            key: 'stats',
                            className: 'file-item-stats',
                        }, [
                            React.createElement('span', { key: 'runs', className: 'file-item-stat' },
                                `${item.stats.execution_count} runs`
                            ),
                        ]),
                        item.type === 'workflow' && React.createElement('button', {
                            key: 'toggle',
                            className: `toggle-btn ${item.enabled ? 'enabled' : ''}`,
                            onClick: (e) => handleToggleEnabled(e, item),
                            'data-testid': `toggle-${item.name}`,
                        }, item.enabled ? 'ON' : 'OFF'),
                        item.type === 'workflow' && React.createElement('div', {
                            key: 'menu',
                            className: 'file-item-menu',
                        }, [
                            React.createElement('button', {
                                key: 'btn',
                                className: 'file-item-menu-btn',
                                onClick: (e) => handleMenuClick(e, item.path),
                                'data-testid': `menu-btn-${item.name}`,
                                dangerouslySetInnerHTML: { __html: menuIcon },
                            }),
                            openMenu === item.path && React.createElement('div', {
                                key: 'dropdown',
                                className: 'file-item-dropdown',
                                'data-testid': `menu-dropdown-${item.name}`,
                            }, [
                                React.createElement('button', {
                                    key: 'execute',
                                    className: 'file-item-dropdown-item',
                                    onClick: (e) => handleExecuteClick(e, item.path),
                                    'data-testid': `menu-execute-${item.name}`,
                                }, 'Execute'),
                            ]),
                        ]),
                    ])
                ),
                ]),
            ]);
        }

        // ExecutionsTab Component
        function ExecutionsTab() {
            const executionsList = useWorkflowStore((state) => state.executionsList);
            const executionsLoading = useWorkflowStore((state) => state.executionsLoading);
            const executionsHasMore = useWorkflowStore((state) => state.executionsHasMore);
            const loadExecutionsList = useWorkflowStore((state) => state.loadExecutionsList);
            const loadExecution = useWorkflowStore((state) => state.loadExecution);
            const listRef = useRef(null);

            // Initial load and auto-refresh every 10 seconds
            useEffect(() => {
                loadExecutionsList(true);
                const interval = setInterval(() => {
                    loadExecutionsList(true);
                }, 10000);
                return () => clearInterval(interval);
            }, []);

            // Infinite scroll - load more when near bottom
            const handleScroll = (e) => {
                const { scrollTop, scrollHeight, clientHeight } = e.target;
                if (scrollHeight - scrollTop - clientHeight < 400 && executionsHasMore && !executionsLoading) {
                    loadExecutionsList(false);
                }
            };

            const formatTime = (timestamp) => {
                if (!timestamp) return '-';
                const date = new Date(timestamp * 1000);
                return date.toLocaleString();
            };

            const formatDuration = (ms) => {
                if (!ms) return '-';
                if (ms < 1000) return `${ms}ms`;
                return `${(ms / 1000).toFixed(1)}s`;
            };

            if (executionsList.length === 0 && !executionsLoading) {
                return React.createElement('div', { className: 'empty-state', 'data-testid': 'executions-tab' },
                    'No executions yet'
                );
            }

            return React.createElement('div', {
                'data-testid': 'executions-tab',
            }, [
                React.createElement('div', {
                    key: 'list',
                    className: 'executions-list',
                    'data-testid': 'executions-list',
                    onScroll: handleScroll,
                    ref: listRef,
                }, [
                ...executionsList.map((exec) =>
                    React.createElement('div', {
                        key: exec.id,
                        className: `execution-item ${exec.status}`,
                        onClick: () => loadExecution(exec.id),
                        'data-testid': `execution-item-${exec.id}`,
                    }, [
                        React.createElement('span', {
                            key: 'time',
                            className: 'exec-time',
                        }, formatTime(exec.completed_at)),
                        React.createElement('span', {
                            key: 'workflow',
                            className: 'exec-workflow',
                        }, exec.workflow_path.replace(/\.json$/, '')),
                        React.createElement('span', {
                            key: 'status',
                            className: `exec-status ${exec.status}`,
                        }, exec.status === 'completed' ? '' : ''),
                        React.createElement('span', {
                            key: 'duration',
                            className: 'exec-duration',
                        }, formatDuration(exec.duration_ms)),
                    ])
                ),
                executionsLoading && React.createElement('div', {
                    key: 'loading',
                    className: 'executions-loading',
                }, 'Loading...'),
                ]),
            ]);
        }

        // Credential Editor Modal Component
        function CredentialEditorModal({ credential, onClose, onSave }) {
            const credentialTypes = window.credentialTypes || [];
            const initialType = credential.type || (credentialTypes[0]?.id || '');

            // Initialize formData with defaults for new credentials
            const getInitialFormData = (typeId) => {
                if (!credential.isNew) return credential.data || {};
                const credType = credentialTypes.find(ct => ct.id === typeId);
                const defaults = {};
                for (const prop of (credType?.properties || [])) {
                    if (prop.default !== undefined) {
                        defaults[prop.id] = prop.default;
                    }
                }
                return defaults;
            };

            const [formData, setFormData] = useState(() => getInitialFormData(initialType));
            const [name, setName] = useState(credential.name || '');
            const [type, setType] = useState(initialType);
            const [testResult, setTestResult] = useState(null);
            const [testing, setTesting] = useState(false);
            const [testPassed, setTestPassed] = useState(!credential.isNew); // Existing credentials don't need re-test
            const testCredentialOnServer = useWorkflowStore((state) => state.testCredentialOnServer);
            const testCredentialData = useWorkflowStore((state) => state.testCredentialData);

            const credType = credentialTypes.find(ct => ct.id === type);
            const properties = credType?.properties || [];
            const HIDE_SENTINEL = 'HIDE_PASSWORD_FOR_SECURITY';

            // Update formData defaults when type changes for new credentials
            useEffect(() => {
                if (credential.isNew) {
                    setFormData(getInitialFormData(type));
                    setTestPassed(false);
                    setTestResult(null);
                }
            }, [type]);

            // Reset test status when form data changes for new credentials
            const handleFieldChange = (fieldId, value) => {
                setFormData(prev => ({ ...prev, [fieldId]: value }));
                if (credential.isNew) {
                    setTestPassed(false);
                    setTestResult(null);
                }
            };

            const handleTest = async () => {
                setTesting(true);
                setTestResult(null);

                let result;
                if (credential.isNew) {
                    // Test data directly for new credentials
                    result = await testCredentialData(type, formData);
                } else {
                    // Test by name for existing credentials
                    result = await testCredentialOnServer(credential.name);
                }

                setTestResult(result);
                setTestPassed(result.status === true);
                setTesting(false);
            };

            const handleSave = () => {
                onSave(name, type, formData);
            };

            // Save is enabled when name and type are set, and test has passed for new credentials
            const canSave = name && type && (testPassed || !credential.isNew);

            return React.createElement('div', { className: 'credential-modal', onClick: (e) => e.target === e.currentTarget && onClose() },
                React.createElement('div', { className: 'credential-modal-content' }, [
                    React.createElement('div', { key: 'header', className: 'credential-modal-header' }, [
                        React.createElement('h2', { key: 'title', className: 'credential-modal-title' },
                            credential.isNew ? 'New Credential' : 'Edit Credential'),
                        React.createElement('button', { key: 'close', className: 'credential-modal-close', onClick: onClose }, '\u00D7'),
                    ]),

                    // Name field
                    React.createElement('div', { key: 'name-group', className: 'credential-form-group' }, [
                        React.createElement('label', { key: 'label', className: 'credential-form-label' }, 'Name'),
                        React.createElement('input', {
                            key: 'input',
                            type: 'text',
                            className: 'credential-form-input',
                            value: name,
                            onChange: (e) => setName(e.target.value),
                            disabled: !credential.isNew,
                            placeholder: 'my-database',
                        }),
                    ]),

                    // Type field (only for new credentials)
                    credential.isNew && React.createElement('div', { key: 'type-group', className: 'credential-form-group' }, [
                        React.createElement('label', { key: 'label', className: 'credential-form-label' }, 'Type'),
                        React.createElement('select', {
                            key: 'select',
                            className: 'credential-form-input',
                            value: type,
                            onChange: (e) => { setType(e.target.value); setFormData({}); },
                        }, credentialTypes.map(ct =>
                            React.createElement('option', { key: ct.id, value: ct.id }, ct.name)
                        )),
                    ]),

                    // Dynamic property fields
                    ...properties.map(prop =>
                        React.createElement('div', { key: prop.id, className: 'credential-form-group' }, [
                            React.createElement('label', { key: 'label', className: 'credential-form-label' }, prop.label),
                            React.createElement('input', {
                                key: 'input',
                                type: prop.private ? 'password' : 'text',
                                className: `credential-form-input ${formData[prop.id] === HIDE_SENTINEL ? 'hidden-value' : ''}`,
                                value: formData[prop.id] === HIDE_SENTINEL ? '(hidden)' : (formData[prop.id] || ''),
                                onChange: (e) => handleFieldChange(prop.id, e.target.value),
                                placeholder: prop.private ? 'Enter to change' : '',
                                onFocus: (e) => {
                                    if (formData[prop.id] === HIDE_SENTINEL) {
                                        handleFieldChange(prop.id, '');
                                        e.target.value = '';
                                    }
                                },
                            }),
                        ])
                    ),

                    // Test result
                    testResult && React.createElement('div', {
                        key: 'test-result',
                        className: `credential-test-result ${testResult.status ? 'success' : 'failure'}`,
                    }, testResult.message || (testResult.status ? 'Connection successful' : 'Connection failed')),

                    // Actions
                    React.createElement('div', { key: 'actions', className: 'credential-modal-actions' }, [
                        React.createElement('button', {
                            key: 'test',
                            className: `credential-modal-btn ${testPassed ? 'test-passed' : 'cancel'}`,
                            onClick: handleTest,
                            disabled: testing,
                        }, testing ? 'Testing...' : testPassed ? 'Test \u2713' : 'Test'),
                        React.createElement('button', {
                            key: 'cancel',
                            className: 'credential-modal-btn cancel',
                            onClick: onClose,
                        }, 'Cancel'),
                        React.createElement('button', {
                            key: 'save',
                            className: 'credential-modal-btn save',
                            onClick: handleSave,
                            disabled: !canSave,
                        }, 'Save'),
                    ]),
                ])
            );
        }

        // Credentials Tab Component
        function CredentialsTab() {
            const credentials = useWorkflowStore((state) => state.credentials);
            const credentialsLoading = useWorkflowStore((state) => state.credentialsLoading);
            const editingCredential = useWorkflowStore((state) => state.editingCredential);
            const loadCredentials = useWorkflowStore((state) => state.loadCredentials);
            const saveCredentialToServer = useWorkflowStore((state) => state.saveCredentialToServer);
            const deleteCredentialFromServer = useWorkflowStore((state) => state.deleteCredentialFromServer);
            const setEditingCredential = useWorkflowStore((state) => state.setEditingCredential);
            const credentialTypes = window.credentialTypes || [];

            // Load credentials on mount
            useEffect(() => {
                loadCredentials();
            }, []);

            const handleNewCredential = () => {
                setEditingCredential({ name: '', type: credentialTypes[0]?.id || '', data: {}, isNew: true });
            };

            const handleEditCredential = async (cred) => {
                // Fetch full credential data
                try {
                    const response = await fetch(`/api/credential/${encodeURIComponent(cred.name)}`);
                    if (response.ok) {
                        const data = await response.json();
                        setEditingCredential({ name: data.name, type: data.type, data: data.data, isNew: false });
                    }
                } catch (e) {
                    console.error('Failed to load credential:', e);
                }
            };

            const handleDeleteCredential = async (name, e) => {
                e.stopPropagation();
                if (confirm(`Delete credential "${name}"?`)) {
                    await deleteCredentialFromServer(name);
                }
            };

            const handleSaveCredential = async (name, type, data) => {
                const success = await saveCredentialToServer(name, type, data);
                if (success) {
                    setEditingCredential(null);
                }
            };

            const getCredTypeName = (typeId) => {
                const ct = credentialTypes.find(c => c.id === typeId);
                return ct?.name || typeId;
            };

            return React.createElement('div', { className: 'credentials-tab' }, [
                // Toolbar
                React.createElement('div', { key: 'toolbar', className: 'workflows-toolbar' }, [
                    React.createElement('button', {
                        key: 'new',
                        className: 'toolbar-btn',
                        onClick: handleNewCredential,
                        disabled: credentialTypes.length === 0,
                    }, [
                        React.createElement('span', { key: 'icon', className: 'toolbar-btn-icon', dangerouslySetInnerHTML: { __html: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>' }}),
                        'New Credential',
                    ]),
                ]),

                // Empty state or list
                credentialsLoading
                    ? React.createElement('div', { key: 'loading' }, 'Loading...')
                    : credentials.length === 0
                    ? React.createElement('div', { key: 'empty', style: { color: '#888', padding: '20px 0' } },
                        credentialTypes.length === 0
                            ? 'No credential types available. Add a module with credential types first.'
                            : 'No credentials configured. Click "New Credential" to add one.')
                    : React.createElement('div', { key: 'list', className: 'credentials-list' },
                        credentials.map(cred =>
                            React.createElement('div', {
                                key: cred.name,
                                className: 'credential-item',
                                onClick: () => handleEditCredential(cred),
                            }, [
                                React.createElement('div', {
                                    key: 'icon',
                                    className: 'credential-icon',
                                    dangerouslySetInnerHTML: { __html: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>' },
                                }),
                                React.createElement('div', { key: 'info', className: 'credential-info' }, [
                                    React.createElement('div', { key: 'name', className: 'credential-name' }, cred.name),
                                    React.createElement('div', { key: 'type', className: 'credential-type' }, getCredTypeName(cred.type)),
                                ]),
                                React.createElement('div', { key: 'actions', className: 'credential-actions' }, [
                                    React.createElement('button', {
                                        key: 'delete',
                                        className: 'credential-action-btn delete',
                                        onClick: (e) => handleDeleteCredential(cred.name, e),
                                    }, 'Delete'),
                                ]),
                            ])
                        )
                    ),

                // Modal
                editingCredential && React.createElement(CredentialEditorModal, {
                    key: 'modal',
                    credential: editingCredential,
                    onClose: () => setEditingCredential(null),
                    onSave: handleSaveCredential,
                }),
            ]);
        }

        // Dashboard Component
        function Dashboard() {
            const dashboardTab = useWorkflowStore((state) => state.dashboardTab);
            const setDashboardTab = useWorkflowStore((state) => state.setDashboardTab);

            return React.createElement('div', { className: 'dashboard', 'data-testid': 'dashboard' }, [
                React.createElement('div', { key: 'header', className: 'dashboard-header' }, [
                    React.createElement('h1', { key: 'title', className: 'dashboard-title', 'data-testid': 'dashboard-title' }, 'dazflow'),
                    React.createElement('div', { key: 'tabs', className: 'dashboard-tabs' }, [
                        React.createElement('button', {
                            key: 'workflows',
                            className: `dashboard-tab ${dashboardTab === 'workflows' ? 'active' : ''}`,
                            onClick: () => setDashboardTab('workflows'),
                            'data-testid': 'tab-workflows',
                        }, 'Workflows'),
                        React.createElement('button', {
                            key: 'executions',
                            className: `dashboard-tab ${dashboardTab === 'executions' ? 'active' : ''}`,
                            onClick: () => setDashboardTab('executions'),
                            'data-testid': 'tab-executions',
                        }, 'Executions'),
                        React.createElement('button', {
                            key: 'credentials',
                            className: `dashboard-tab ${dashboardTab === 'credentials' ? 'active' : ''}`,
                            onClick: () => setDashboardTab('credentials'),
                            'data-testid': 'tab-credentials',
                        }, 'Credentials'),
                    ]),
                ]),
                React.createElement('div', { key: 'content', className: 'dashboard-content' },
                    dashboardTab === 'workflows'
                        ? React.createElement(WorkflowsTab)
                        : dashboardTab === 'executions'
                        ? React.createElement(ExecutionsTab)
                        : React.createElement(CredentialsTab)
                ),
            ]);
        }

        // Sidebar Component
        function Sidebar({ onAddNode }) {
            const baseCategorized = getNodeTypesByCategory();
            const nodes = useWorkflowStore((state) => state.nodes);
            const connections = useWorkflowStore((state) => state.connections);
            const ambientExecution = useWorkflowStore((state) => state.ambientExecution);
            const goToDashboard = useWorkflowStore((state) => state.goToDashboard);
            const isReadOnly = useWorkflowStore((state) => state.isReadOnly);
            const credentials = useWorkflowStore((state) => state.credentials);
            const loadCredentials = useWorkflowStore((state) => state.loadCredentials);
            const saveWorkflow = useWorkflowStore((state) => state.saveWorkflow);
            const currentWorkflowPath = useWorkflowStore((state) => state.currentWorkflowPath);
            const [showJson, setShowJson] = useState(false);
            const [saveStatus, setSaveStatus] = useState(null); // null, 'saving', 'saved', 'error'

            const handleSave = async () => {
                if (!currentWorkflowPath || isReadOnly) return;
                setSaveStatus('saving');
                const success = await saveWorkflow(currentWorkflowPath);
                setSaveStatus(success ? 'saved' : 'error');
                // Clear status after 2 seconds
                setTimeout(() => setSaveStatus(null), 2000);
            };

            // Load credentials on mount
            useEffect(() => {
                loadCredentials();
            }, []);

            // Expand node types that require credentials
            // For each node with requiredCredential, create one entry per matching credential
            const categorized = useMemo(() => {
                // Group credentials by type
                const credentialsByType = {};
                for (const cred of credentials) {
                    if (!credentialsByType[cred.type]) {
                        credentialsByType[cred.type] = [];
                    }
                    credentialsByType[cred.type].push(cred);
                }

                // Expand categorized node types
                const expanded = {};
                for (const [category, types] of Object.entries(baseCategorized)) {
                    expanded[category] = [];
                    for (const nt of types) {
                        if (nt.requiredCredential) {
                            // Create one entry per credential of the required type
                            const creds = credentialsByType[nt.requiredCredential] || [];
                            for (const cred of creds) {
                                expanded[category].push({
                                    ...nt,
                                    sidebarId: `${nt.id}:${cred.name}`,
                                    displayName: `${cred.name} ${nt.name}`,
                                    credentialName: cred.name,
                                });
                            }
                        } else {
                            expanded[category].push({ ...nt, sidebarId: nt.id, displayName: nt.name });
                        }
                    }
                }
                return expanded;
            }, [baseCategorized, credentials]);

            function handleDragStart(event, item) {
                if (isReadOnly) return;
                // Encode both typeId and credentialName
                const dragData = JSON.stringify({ typeId: item.id, credentialName: item.credentialName });
                event.dataTransfer.setData('application/reactflow', dragData);
                event.dataTransfer.effectAllowed = 'move';
            }

            function handleClick(item) {
                if (isReadOnly) return;
                // Stagger position based on current node count to avoid overlap
                const offset = nodes.length * 40;
                onAddNode(item.id, { x: 300 + offset, y: 200 + offset }, item.credentialName);
            }

            // Instance = workflow definition + execution state
            const instanceJson = JSON.stringify({
                workflow: { nodes, connections },
                execution: ambientExecution,
            }, null, 2);

            return React.createElement('div', { className: 'sidebar', 'data-testid': 'sidebar' }, [
                !isReadOnly && React.createElement('div', { key: 'sidebar-actions', className: 'sidebar-actions' }, [
                    React.createElement('button', {
                        key: 'back',
                        className: 'back-btn',
                        onClick: goToDashboard,
                        'data-testid': 'back-to-dashboard',
                    }, '\u2190 Dashboard'),
                    React.createElement('button', {
                        key: 'save',
                        className: `save-btn${saveStatus === 'saved' ? ' saved' : ''}${saveStatus === 'error' ? ' error' : ''}`,
                        onClick: handleSave,
                        disabled: saveStatus === 'saving',
                        'data-testid': 'save-workflow',
                    }, saveStatus === 'saving' ? 'Saving...' : saveStatus === 'saved' ? 'Saved!' : saveStatus === 'error' ? 'Error' : 'Save'),
                ]),
                React.createElement('div', { key: 'title', className: 'sidebar-title', 'data-testid': 'sidebar-title' }, 'Nodes'),
                ...Object.entries(categorized).filter(([_, items]) => items.length > 0).map(([category, items]) =>
                    React.createElement('div', { key: category, className: 'category-group', style: isReadOnly ? { opacity: 0.5, pointerEvents: 'none' } : {} }, [
                        React.createElement('div', { key: 'label', className: 'category-label' }, category),
                        React.createElement('div', { key: 'items', className: 'category-items' },
                            items.map((item) =>
                                React.createElement('div', {
                                    key: item.sidebarId,
                                    className: `node-type-item${isReadOnly ? ' disabled' : ''}`,
                                    'data-testid': `node-type-${item.id}`,
                                    onClick: () => handleClick(item),
                                    draggable: !isReadOnly,
                                    onDragStart: (e) => handleDragStart(e, item),
                                }, [
                                    React.createElement('div', {
                                        key: 'icon',
                                        dangerouslySetInnerHTML: { __html: item.icon },
                                    }),
                                    React.createElement('span', { key: 'name' }, item.displayName),
                                ])
                            )
                        ),
                    ])
                ),
                React.createElement('div', { key: 'footer', className: 'sidebar-footer' }, [
                    React.createElement('button', {
                        key: 'json-btn',
                        className: 'view-json-btn',
                        'data-testid': 'view-json-btn',
                        onClick: () => setShowJson(true),
                    }, 'View Instance'),
                    React.createElement('div', {
                        key: 'hint',
                        className: 'sidebar-hint',
                        'data-testid': 'sidebar-hint',
                    }, isReadOnly ? 'Read-only mode' : 'Click or drag to add'),
                ]),
                React.createElement(JsonModal, {
                    key: 'modal',
                    isOpen: showJson,
                    onClose: () => setShowJson(false),
                    json: instanceJson,
                }),
            ]);
        }

        // Canvas Component
        function Canvas({ onAddNode }) {
            const reactFlowInstance = useRef(null);
            const hasRestoredViewport = useRef(false);

            const workflowNodes = useWorkflowStore((state) => state.nodes);
            const connections = useWorkflowStore((state) => state.connections);
            const selectedNodeIds = useWorkflowStore((state) => state.selectedNodeIds);
            const selectedEdgeIds = useWorkflowStore((state) => state.selectedEdgeIds);
            const storedViewport = useWorkflowStore((state) => state.viewport);
            const updateNodePosition = useWorkflowStore((state) => state.updateNodePosition);
            const addConnection = useWorkflowStore((state) => state.addConnection);
            const removeConnection = useWorkflowStore((state) => state.removeConnection);
            const selectNodes = useWorkflowStore((state) => state.selectNodes);
            const selectEdges = useWorkflowStore((state) => state.selectEdges);
            const removeNode = useWorkflowStore((state) => state.removeNode);
            const setViewport = useWorkflowStore((state) => state.setViewport);
            const setOpenEditorNodeId = useWorkflowStore((state) => state.setOpenEditorNodeId);

            const nodes = useMemo(() => {
                return workflowNodes.map((wn) => ({
                    id: wn.id,
                    type: 'custom',
                    position: wn.position,
                    data: { workflowNode: wn },
                    selected: selectedNodeIds.includes(wn.id),
                }));
            }, [workflowNodes, selectedNodeIds]);

            const edges = useMemo(() => {
                return connections.map((c) => ({
                    id: c.id,
                    source: c.sourceNodeId,
                    sourceHandle: c.sourceConnectorId,
                    target: c.targetNodeId,
                    targetHandle: c.targetConnectorId,
                    type: 'custom',
                    selected: selectedEdgeIds.includes(c.id),
                }));
            }, [connections, selectedEdgeIds]);

            const onNodesChange = useCallback((changes) => {
                for (const change of changes) {
                    if (change.type === 'position' && change.position) {
                        updateNodePosition(change.id, change.position);
                    }
                    if (change.type === 'remove') {
                        removeNode(change.id);
                    }
                }
                const selectChanges = changes.filter((c) => c.type === 'select');
                if (selectChanges.length > 0) {
                    const newNodes = applyNodeChanges(changes, nodes);
                    const newSelectedIds = newNodes.filter((n) => n.selected).map((n) => n.id);
                    selectNodes(newSelectedIds);
                }
            }, [updateNodePosition, removeNode, selectNodes, nodes]);

            const onEdgesChange = useCallback((changes) => {
                for (const change of changes) {
                    if (change.type === 'remove') {
                        removeConnection(change.id);
                    }
                }
                const selectChanges = changes.filter((c) => c.type === 'select');
                if (selectChanges.length > 0) {
                    const newEdges = applyEdgeChanges(changes, edges);
                    const newSelectedIds = newEdges.filter((e) => e.selected).map((e) => e.id);
                    selectEdges(newSelectedIds);
                }
            }, [removeConnection, selectEdges, edges]);

            const onConnect = useCallback((connection) => {
                if (connection.source && connection.target && connection.sourceHandle && connection.targetHandle) {
                    addConnection({
                        sourceNodeId: connection.source,
                        sourceConnectorId: connection.sourceHandle,
                        targetNodeId: connection.target,
                        targetConnectorId: connection.targetHandle,
                    });
                }
            }, [addConnection]);

            const isValidConnection = useCallback((connection) => {
                if (connection.source === connection.target) return false;
                const sourceNode = workflowNodes.find((n) => n.id === connection.source);
                const targetNode = workflowNodes.find((n) => n.id === connection.target);
                if (!sourceNode || !targetNode) return false;
                const sourceType = nodeTypeDefinitions[sourceNode.typeId];
                const targetType = nodeTypeDefinitions[targetNode.typeId];
                if (!sourceType || !targetType) return false;
                const sourceConnectors = sourceType.getConnectors(sourceNode.data);
                const targetConnectors = targetType.getConnectors(targetNode.data);
                const hasSourceHandle = sourceConnectors.outputs.some((o) => o.id === connection.sourceHandle);
                const hasTargetHandle = targetConnectors.inputs.some((i) => i.id === connection.targetHandle);
                return hasSourceHandle && hasTargetHandle;
            }, [workflowNodes]);

            const onDragOver = useCallback((event) => {
                event.preventDefault();
                event.dataTransfer.dropEffect = 'move';
            }, []);

            const onDrop = useCallback((event) => {
                event.preventDefault();
                const rawData = event.dataTransfer.getData('application/reactflow');
                if (!rawData || !reactFlowInstance.current) return;

                // Parse drag data - can be JSON with typeId and credentialName, or just typeId string
                let typeId, credentialName;
                try {
                    const parsed = JSON.parse(rawData);
                    typeId = parsed.typeId;
                    credentialName = parsed.credentialName;
                } catch {
                    typeId = rawData;
                    credentialName = null;
                }

                const position = reactFlowInstance.current.screenToFlowPosition({
                    x: event.clientX,
                    y: event.clientY,
                });
                onAddNode(typeId, position, credentialName);
            }, [onAddNode]);

            const onMoveEnd = useCallback((event, viewport) => {
                setViewport({ x: viewport.x, y: viewport.y, zoom: viewport.zoom });
            }, [setViewport]);

            const onNodeClick = useCallback((event, node) => {
                selectNodes([node.id]);
            }, [selectNodes]);

            const onNodeDoubleClick = useCallback((event, node) => {
                setOpenEditorNodeId(node.id);
            }, [setOpenEditorNodeId]);

            const onPaneClick = useCallback(() => {
                selectNodes([]);
            }, [selectNodes]);

            const onInit = useCallback((instance) => {
                reactFlowInstance.current = instance;
                // Restore viewport from storage if we have one and haven't already
                if (!hasRestoredViewport.current && storedViewport && (storedViewport.x !== 0 || storedViewport.y !== 0 || storedViewport.zoom !== 1)) {
                    hasRestoredViewport.current = true;
                    instance.setViewport(storedViewport);
                }
            }, [storedViewport]);

            // Determine if we should fitView (only when no stored viewport with nodes)
            const shouldFitView = !initialState || initialState.nodes.length === 0;

            return React.createElement('div', { className: 'canvas-container', 'data-testid': 'canvas' },
                React.createElement(ReactFlow, {
                    nodes,
                    edges,
                    onNodesChange,
                    onEdgesChange,
                    onConnect,
                    isValidConnection,
                    nodeTypes,
                    edgeTypes,
                    onInit,
                    onMoveEnd,
                    onNodeClick,
                    onNodeDoubleClick,
                    onPaneClick,
                    onDragOver,
                    onDrop,
                    fitView: shouldFitView,
                    fitViewOptions: { padding: 0.2 },
                    defaultViewport: storedViewport,
                    minZoom: 0.1,
                    maxZoom: 2,
                    panOnDrag: [1, 2],
                    selectionOnDrag: true,
                    selectNodesOnDrag: false,
                    defaultEdgeOptions: { type: 'custom' },
                }, [
                    React.createElement(Background, {
                        key: 'bg',
                        variant: 'dots',
                        gap: 20,
                        size: 1,
                        color: '#3a3a5e',
                    }),
                    React.createElement(Controls, { key: 'controls' }),
                    // SVG defs for arrow marker
                    React.createElement('svg', { key: 'defs' },
                        React.createElement('defs', null,
                            React.createElement('marker', {
                                id: 'arrow',
                                viewBox: '0 0 10 10',
                                refX: '8',
                                refY: '5',
                                markerWidth: '6',
                                markerHeight: '6',
                                orient: 'auto-start-reverse',
                            },
                                React.createElement('path', {
                                    d: 'M 0 0 L 10 5 L 0 10 z',
                                    fill: '#5a5a7a',
                                })
                            )
                        )
                    ),
                ])
            );
        }

        // Editor Component
        function Editor() {
            const addNode = useWorkflowStore((state) => state.addNode);
            const deleteSelected = useWorkflowStore((state) => state.deleteSelected);
            const selectNodes = useWorkflowStore((state) => state.selectNodes);
            const clearSelection = useWorkflowStore((state) => state.clearSelection);
            const selectedNodeIds = useWorkflowStore((state) => state.selectedNodeIds);
            const editingNodeId = useWorkflowStore((state) => state.editingNodeId);
            const setEditingNodeId = useWorkflowStore((state) => state.setEditingNodeId);
            const openEditorNodeId = useWorkflowStore((state) => state.openEditorNodeId);
            const setOpenEditorNodeId = useWorkflowStore((state) => state.setOpenEditorNodeId);
            const nodes = useWorkflowStore((state) => state.nodes);
            const isReadOnly = useWorkflowStore((state) => state.isReadOnly);
            const executionViewerData = useWorkflowStore((state) => state.executionViewerData);
            const closeExecutionViewer = useWorkflowStore((state) => state.closeExecutionViewer);

            // Keyboard shortcuts
            useEffect(() => {
                function handleKeyDown(event) {
                    const target = event.target;
                    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.tagName === 'SELECT') return;

                    // Don't handle shortcuts if node editor is open or read-only
                    if (openEditorNodeId || isReadOnly) return;

                    if (event.key === 'Delete' || event.key === 'Backspace') {
                        event.preventDefault();
                        deleteSelected();
                    }
                    if ((event.ctrlKey || event.metaKey) && event.key === 'a') {
                        event.preventDefault();
                        selectNodes(nodes.map((n) => n.id));
                    }
                    if (event.key === 'Escape') {
                        if (editingNodeId) {
                            setEditingNodeId(null);
                        } else {
                            clearSelection();
                        }
                    }
                    if (event.key === ' ' && selectedNodeIds.length === 1 && !editingNodeId) {
                        event.preventDefault();
                        setEditingNodeId(selectedNodeIds[0]);
                    }
                }
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [deleteSelected, selectNodes, clearSelection, nodes, selectedNodeIds, editingNodeId, setEditingNodeId, openEditorNodeId, isReadOnly]);

            const handleAddNode = useCallback((typeId, position, credentialName = null) => {
                if (isReadOnly) return;
                addNode(typeId, position, credentialName);
            }, [addNode, isReadOnly]);

            const formatTimestamp = (ts) => {
                if (!ts) return '';
                return new Date(ts * 1000).toLocaleString();
            };

            return React.createElement(ReactFlowProvider, null, [
                isReadOnly && executionViewerData && React.createElement('div', {
                    key: 'readonly-banner',
                    className: 'readonly-banner',
                    'data-testid': 'readonly-banner',
                }, [
                    React.createElement('div', { key: 'text', className: 'readonly-banner-text' }, [
                        React.createElement('span', { key: 'icon' }, ''),
                        React.createElement('span', { key: 'msg' },
                            `Viewing execution from ${formatTimestamp(executionViewerData.completed_at)} - Read Only`
                        ),
                    ]),
                    React.createElement('button', {
                        key: 'close',
                        className: 'readonly-banner-close',
                        onClick: closeExecutionViewer,
                        'data-testid': 'readonly-back-btn',
                    }, ' Back to Executions'),
                ]),
                React.createElement('div', { key: 'main', className: 'editor', 'data-testid': 'editor' }, [
                    React.createElement(Sidebar, { key: 'sidebar', onAddNode: handleAddNode }),
                    React.createElement(Canvas, { key: 'canvas', onAddNode: handleAddNode }),
                ]),
                openEditorNodeId && React.createElement(NodeEditorDialog, {
                    key: 'node-editor',
                    nodeId: openEditorNodeId,
                    onClose: () => setOpenEditorNodeId(null),
                }),
            ]);
        }

        // App Component
        function App() {
            const currentView = useWorkflowStore((state) => state.currentView);
            const loadWorkflow = useWorkflowStore((state) => state.loadWorkflow);
            const loadExecution = useWorkflowStore((state) => state.loadExecution);
            const loadDashboardItems = useWorkflowStore((state) => state.loadDashboardItems);
            const [initialLoad, setInitialLoad] = useState(true);

            // Handle URL pathname navigation (initial load and browser back/forward)
            useEffect(() => {
                const handleNavigation = () => {
                    const pathname = window.location.pathname;

                    if (pathname.startsWith('/editor/')) {
                        // Decode URL-encoded path and add .json extension if not present
                        let path = decodeURIComponent(pathname.slice(8));
                        if (!path.endsWith('.json')) {
                            path = path + '.json';
                        }
                        loadWorkflow(path);
                    } else if (pathname.startsWith('/execution/')) {
                        const id = decodeURIComponent(pathname.slice(11));
                        loadExecution(id);
                    } else {
                        // Back to dashboard
                        const newTab = pathname === '/executions' ? 'executions' : 'workflows';
                        useWorkflowStore.setState({
                            currentView: 'dashboard',
                            dashboardTab: newTab,
                            isReadOnly: false,
                            executionViewerId: null,
                            currentWorkflowPath: null,
                        });
                        loadDashboardItems('');
                    }
                };

                // Handle initial load
                if (initialLoad) {
                    setInitialLoad(false);
                    const pathname = window.location.pathname;
                    if (pathname.startsWith('/editor/') || pathname.startsWith('/execution/')) {
                        handleNavigation();
                    }
                }

                // Listen for browser back/forward
                window.addEventListener('popstate', handleNavigation);
                return () => window.removeEventListener('popstate', handleNavigation);
            }, [initialLoad, loadWorkflow, loadExecution, loadDashboardItems]);

            if (currentView === 'dashboard') {
                return React.createElement(Dashboard);
            }
            return React.createElement(Editor);
        }

        // Load modules and mount app
        async function initApp() {
            // Load modules before rendering
            const moduleData = await loadModules();

            // Store credential types in window for now (will move to Zustand in Phase 6)
            window.credentialTypes = moduleData.credentialTypes || [];

            const root = createRoot(document.getElementById('root'));
            root.render(React.createElement(App));
        }

        initApp();
    </script>
</body>
</html>
